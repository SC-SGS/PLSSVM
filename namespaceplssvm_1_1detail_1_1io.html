<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PLSSVM - Parallel Least Squares Support Vector Machine: plssvm::detail::io Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_90x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PLSSVM - Parallel Least Squares Support Vector Machine
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
   <div id="projectbrief">A Least Squares Support Vector Machine implementation using different backends.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceplssvm.html">plssvm</a></li><li class="navelem"><a class="el" href="namespaceplssvm_1_1detail.html">detail</a></li><li class="navelem"><a class="el" href="namespaceplssvm_1_1detail_1_1io.html">io</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">plssvm::detail::io Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace containing implementation details for the IO related functions. <b>Should not</b> directly be used by users.  
<a href="namespaceplssvm_1_1detail_1_1io.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplssvm_1_1detail_1_1io_1_1file__reader.html">file_reader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The plssvm::detail::file_reader class is responsible for reading a file and splitting it into its lines.  <a href="classplssvm_1_1detail_1_1io_1_1file__reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a92a6503559420565906a3b5dea9140a6"><td class="memTemplParams" colspan="2">template&lt;typename label_type &gt; </td></tr>
<tr class="memitem:a92a6503559420565906a3b5dea9140a6"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; std::size_t, std::size_t, std::set&lt; label_type &gt;, std::size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm_1_1detail_1_1io.html#a92a6503559420565906a3b5dea9140a6">parse_arff_header</a> (const std::vector&lt; std::string_view &gt; &amp;lines)</td></tr>
<tr class="memdesc:a92a6503559420565906a3b5dea9140a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the ARFF file header, i.e., determine the number of features, the length of the ARRF header, whether the data set is annotated with labels and at which position the label is written in the data set.  <a href="namespaceplssvm_1_1detail_1_1io.html#a92a6503559420565906a3b5dea9140a6">More...</a><br /></td></tr>
<tr class="separator:a92a6503559420565906a3b5dea9140a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac191b22d5eb5c6c8592dc80bacf68b9f"><td class="memTemplParams" colspan="2">template&lt;typename real_type , typename label_type &gt; </td></tr>
<tr class="memitem:ac191b22d5eb5c6c8592dc80bacf68b9f"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; std::size_t, std::size_t, std::vector&lt; std::vector&lt; real_type &gt; &gt;, std::vector&lt; label_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm_1_1detail_1_1io.html#ac191b22d5eb5c6c8592dc80bacf68b9f">parse_arff_data</a> (const <a class="el" href="classplssvm_1_1detail_1_1io_1_1file__reader.html">file_reader</a> &amp;reader)</td></tr>
<tr class="memdesc:ac191b22d5eb5c6c8592dc80bacf68b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse all data points and potential label using the file <code>reader</code>, ignoring all empty lines and lines starting with an <code>%</code>. If no labels are found, returns an empty vector.  <a href="namespaceplssvm_1_1detail_1_1io.html#ac191b22d5eb5c6c8592dc80bacf68b9f">More...</a><br /></td></tr>
<tr class="separator:ac191b22d5eb5c6c8592dc80bacf68b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79aa7936c5a01d6bfd7082ec9abb0c50"><td class="memTemplParams" colspan="2">template&lt;typename real_type , typename label_type , bool has_label&gt; </td></tr>
<tr class="memitem:a79aa7936c5a01d6bfd7082ec9abb0c50"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm_1_1detail_1_1io.html#a79aa7936c5a01d6bfd7082ec9abb0c50">write_arff_data_impl</a> (const std::string &amp;filename, const std::vector&lt; std::vector&lt; real_type &gt;&gt; &amp;data, const std::vector&lt; label_type &gt; &amp;label)</td></tr>
<tr class="memdesc:a79aa7936c5a01d6bfd7082ec9abb0c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the provided <code>data</code> and <code>labels</code> to the ARFF file <code>filename</code>.  <a href="namespaceplssvm_1_1detail_1_1io.html#a79aa7936c5a01d6bfd7082ec9abb0c50">More...</a><br /></td></tr>
<tr class="separator:a79aa7936c5a01d6bfd7082ec9abb0c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5792cccaf8c7589afe19482b4a26b6"><td class="memTemplParams" colspan="2">template&lt;typename real_type , typename label_type &gt; </td></tr>
<tr class="memitem:a6a5792cccaf8c7589afe19482b4a26b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm_1_1detail_1_1io.html#a6a5792cccaf8c7589afe19482b4a26b6">write_arff_data</a> (const std::string &amp;filename, const std::vector&lt; std::vector&lt; real_type &gt;&gt; &amp;data, const std::vector&lt; label_type &gt; &amp;label)</td></tr>
<tr class="memdesc:a6a5792cccaf8c7589afe19482b4a26b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the provided <code>data</code> and <code>labels</code> to the ARFF file <code>filename</code>.  <a href="namespaceplssvm_1_1detail_1_1io.html#a6a5792cccaf8c7589afe19482b4a26b6">More...</a><br /></td></tr>
<tr class="separator:a6a5792cccaf8c7589afe19482b4a26b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72f588448e28ad163567b9f95e515c3"><td class="memTemplParams" colspan="2">template&lt;typename real_type &gt; </td></tr>
<tr class="memitem:aa72f588448e28ad163567b9f95e515c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm_1_1detail_1_1io.html#aa72f588448e28ad163567b9f95e515c3">write_arff_data</a> (const std::string &amp;filename, const std::vector&lt; std::vector&lt; real_type &gt;&gt; &amp;data)</td></tr>
<tr class="memdesc:aa72f588448e28ad163567b9f95e515c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the provided <code>data</code> to the ARFF file <code>filename</code>.  <a href="namespaceplssvm_1_1detail_1_1io.html#aa72f588448e28ad163567b9f95e515c3">More...</a><br /></td></tr>
<tr class="separator:aa72f588448e28ad163567b9f95e515c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e404e093dfe9bc546a6def2275eef91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm_1_1detail_1_1io.html#a0e404e093dfe9bc546a6def2275eef91">swap</a> (<a class="el" href="classplssvm_1_1detail_1_1io_1_1file__reader.html">file_reader</a> &amp;lhs, <a class="el" href="classplssvm_1_1detail_1_1io_1_1file__reader.html">file_reader</a> &amp;rhs)</td></tr>
<tr class="memdesc:a0e404e093dfe9bc546a6def2275eef91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise swap the contents of <code>lhs</code> and <code>rhs</code>.  <a href="namespaceplssvm_1_1detail_1_1io.html#a0e404e093dfe9bc546a6def2275eef91">More...</a><br /></td></tr>
<tr class="separator:a0e404e093dfe9bc546a6def2275eef91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2cb179f876b1fe3cd185ca228d0aa2d"><td class="memTemplParams" colspan="2">template&lt;typename real_type , typename label_type , typename size_type &gt; </td></tr>
<tr class="memitem:ab2cb179f876b1fe3cd185ca228d0aa2d"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="namespaceplssvm.html#adfeda8d422840acb79679d17737238fc">plssvm::parameter</a>, real_type, std::vector&lt; label_type &gt;, std::size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm_1_1detail_1_1io.html#ab2cb179f876b1fe3cd185ca228d0aa2d">parse_libsvm_model_header</a> (const std::vector&lt; std::string_view &gt; &amp;lines)</td></tr>
<tr class="memdesc:ab2cb179f876b1fe3cd185ca228d0aa2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the LIBSVM model file header.  <a href="namespaceplssvm_1_1detail_1_1io.html#ab2cb179f876b1fe3cd185ca228d0aa2d">More...</a><br /></td></tr>
<tr class="separator:ab2cb179f876b1fe3cd185ca228d0aa2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6ca0f063f1e6a8c107267326ae9182"><td class="memTemplParams" colspan="2">template&lt;typename real_type , typename label_type &gt; </td></tr>
<tr class="memitem:a3d6ca0f063f1e6a8c107267326ae9182"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; label_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm_1_1detail_1_1io.html#a3d6ca0f063f1e6a8c107267326ae9182">write_libsvm_model_header</a> (fmt::ostream &amp;out, const <a class="el" href="namespaceplssvm.html#adfeda8d422840acb79679d17737238fc">plssvm::parameter</a> &amp;params, const real_type rho, const <a class="el" href="classplssvm_1_1data__set.html">data_set</a>&lt; real_type, label_type &gt; &amp;data)</td></tr>
<tr class="memdesc:a3d6ca0f063f1e6a8c107267326ae9182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the LIBSVM model file header to <code>out</code>.  <a href="namespaceplssvm_1_1detail_1_1io.html#a3d6ca0f063f1e6a8c107267326ae9182">More...</a><br /></td></tr>
<tr class="separator:a3d6ca0f063f1e6a8c107267326ae9182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd7c8c3e979f6fd4f70f6e065850389"><td class="memTemplParams" colspan="2">template&lt;typename real_type , typename label_type &gt; </td></tr>
<tr class="memitem:a7bd7c8c3e979f6fd4f70f6e065850389"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm_1_1detail_1_1io.html#a7bd7c8c3e979f6fd4f70f6e065850389">write_libsvm_model_data</a> (const std::string &amp;filename, const <a class="el" href="namespaceplssvm.html#adfeda8d422840acb79679d17737238fc">plssvm::parameter</a> &amp;params, const real_type rho, const std::vector&lt; real_type &gt; &amp;alpha, const <a class="el" href="classplssvm_1_1data__set.html">data_set</a>&lt; real_type, label_type &gt; &amp;data)</td></tr>
<tr class="memdesc:a7bd7c8c3e979f6fd4f70f6e065850389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the LIBSVM model to the file <code>filename</code>.  <a href="namespaceplssvm_1_1detail_1_1io.html#a7bd7c8c3e979f6fd4f70f6e065850389">More...</a><br /></td></tr>
<tr class="separator:a7bd7c8c3e979f6fd4f70f6e065850389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58f53f9f473ed6db8fb23cd15a4707d"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm_1_1detail_1_1io.html#ac58f53f9f473ed6db8fb23cd15a4707d">parse_libsvm_num_features</a> (const std::vector&lt; std::string_view &gt; &amp;lines, const std::size_t skipped_lines=0)</td></tr>
<tr class="memdesc:ac58f53f9f473ed6db8fb23cd15a4707d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the maximum number of features per data point given in <code>lines</code>, where the first <code>skipped_lines</code> are skipped.  <a href="namespaceplssvm_1_1detail_1_1io.html#ac58f53f9f473ed6db8fb23cd15a4707d">More...</a><br /></td></tr>
<tr class="separator:ac58f53f9f473ed6db8fb23cd15a4707d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b739cc5f15bdc4e4e130994ff3575a"><td class="memTemplParams" colspan="2">template&lt;typename real_type , typename label_type &gt; </td></tr>
<tr class="memitem:a04b739cc5f15bdc4e4e130994ff3575a"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; std::size_t, std::size_t, std::vector&lt; std::vector&lt; real_type &gt; &gt;, std::vector&lt; label_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm_1_1detail_1_1io.html#a04b739cc5f15bdc4e4e130994ff3575a">parse_libsvm_data</a> (const <a class="el" href="classplssvm_1_1detail_1_1io_1_1file__reader.html">file_reader</a> &amp;reader, const std::size_t skipped_lines=0)</td></tr>
<tr class="memdesc:a04b739cc5f15bdc4e4e130994ff3575a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse all data points and potential label using the file <code>reader</code>, ignoring all empty lines and lines starting with an <code>#</code>. If no labels are found, returns an empty vector.  <a href="namespaceplssvm_1_1detail_1_1io.html#a04b739cc5f15bdc4e4e130994ff3575a">More...</a><br /></td></tr>
<tr class="separator:a04b739cc5f15bdc4e4e130994ff3575a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536e8424f22af7875dbb721905cfc708"><td class="memTemplParams" colspan="2">template&lt;typename real_type , typename label_type , bool has_label&gt; </td></tr>
<tr class="memitem:a536e8424f22af7875dbb721905cfc708"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm_1_1detail_1_1io.html#a536e8424f22af7875dbb721905cfc708">write_libsvm_data_impl</a> (const std::string &amp;filename, const std::vector&lt; std::vector&lt; real_type &gt;&gt; &amp;data, const std::vector&lt; label_type &gt; &amp;label)</td></tr>
<tr class="memdesc:a536e8424f22af7875dbb721905cfc708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the provided <code>data</code> and <code>labels</code> to the LIBSVM file <code>filename</code>.  <a href="namespaceplssvm_1_1detail_1_1io.html#a536e8424f22af7875dbb721905cfc708">More...</a><br /></td></tr>
<tr class="separator:a536e8424f22af7875dbb721905cfc708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6d12d43593395796b3dcbd9dcdecd6"><td class="memTemplParams" colspan="2">template&lt;typename real_type , typename label_type &gt; </td></tr>
<tr class="memitem:aba6d12d43593395796b3dcbd9dcdecd6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm_1_1detail_1_1io.html#aba6d12d43593395796b3dcbd9dcdecd6">write_libsvm_data</a> (const std::string &amp;filename, const std::vector&lt; std::vector&lt; real_type &gt;&gt; &amp;data, const std::vector&lt; label_type &gt; &amp;label)</td></tr>
<tr class="memdesc:aba6d12d43593395796b3dcbd9dcdecd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the provided <code>data</code> and <code>labels</code> to the LIBSVM file <code>filename</code>.  <a href="namespaceplssvm_1_1detail_1_1io.html#aba6d12d43593395796b3dcbd9dcdecd6">More...</a><br /></td></tr>
<tr class="separator:aba6d12d43593395796b3dcbd9dcdecd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7f80352122a94464be164fe2202c93"><td class="memTemplParams" colspan="2">template&lt;typename real_type &gt; </td></tr>
<tr class="memitem:a8b7f80352122a94464be164fe2202c93"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm_1_1detail_1_1io.html#a8b7f80352122a94464be164fe2202c93">write_libsvm_data</a> (const std::string &amp;filename, const std::vector&lt; std::vector&lt; real_type &gt;&gt; &amp;data)</td></tr>
<tr class="memdesc:a8b7f80352122a94464be164fe2202c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the provided <code>data</code> to the LIBSVM file <code>filename</code>.  <a href="namespaceplssvm_1_1detail_1_1io.html#a8b7f80352122a94464be164fe2202c93">More...</a><br /></td></tr>
<tr class="separator:a8b7f80352122a94464be164fe2202c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64aaa2ab0695c4fd2068fd6a41c0a362"><td class="memTemplParams" colspan="2">template&lt;typename real_type , typename factors_type &gt; </td></tr>
<tr class="memitem:a64aaa2ab0695c4fd2068fd6a41c0a362"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; std::pair&lt; real_type, real_type &gt;, std::vector&lt; factors_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm_1_1detail_1_1io.html#a64aaa2ab0695c4fd2068fd6a41c0a362">parse_scaling_factors</a> (const <a class="el" href="classplssvm_1_1detail_1_1io_1_1file__reader.html">file_reader</a> &amp;reader)</td></tr>
<tr class="memdesc:a64aaa2ab0695c4fd2068fd6a41c0a362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the scaling interval and factors stored using LIBSVM's file format from the file <code>filename</code>.  <a href="namespaceplssvm_1_1detail_1_1io.html#a64aaa2ab0695c4fd2068fd6a41c0a362">More...</a><br /></td></tr>
<tr class="separator:a64aaa2ab0695c4fd2068fd6a41c0a362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d879ca1fc76f9a75a9dc472d36686f5"><td class="memTemplParams" colspan="2">template&lt;typename real_type , typename factors_type &gt; </td></tr>
<tr class="memitem:a6d879ca1fc76f9a75a9dc472d36686f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm_1_1detail_1_1io.html#a6d879ca1fc76f9a75a9dc472d36686f5">write_scaling_factors</a> (const std::string &amp;filename, const std::pair&lt; real_type, real_type &gt; &amp;scaling_interval, const std::vector&lt; factors_type &gt; &amp;scaling_factors)</td></tr>
<tr class="memdesc:a6d879ca1fc76f9a75a9dc472d36686f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the <code>scaling_interval</code> and <code>scaling_factors</code> to a file for later usage in scaling another data set using LIBSVM's file format.  <a href="namespaceplssvm_1_1detail_1_1io.html#a6d879ca1fc76f9a75a9dc472d36686f5">More...</a><br /></td></tr>
<tr class="separator:a6d879ca1fc76f9a75a9dc472d36686f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace containing implementation details for the IO related functions. <b>Should not</b> directly be used by users. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a92a6503559420565906a3b5dea9140a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a6503559420565906a3b5dea9140a6">&#9670;&nbsp;</a></span>parse_arff_header()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename label_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;std::size_t, std::size_t, std::set&lt;label_type&gt;, std::size_t&gt; plssvm::detail::io::parse_arff_header </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string_view &gt; &amp;&#160;</td>
          <td class="paramname"><em>lines</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the ARFF file header, i.e., determine the number of features, the length of the ARRF header, whether the data set is annotated with labels and at which position the label is written in the data set. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">label_type</td><td>the type of the labels (any arithmetic type or std::string) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lines</td><td>the ARFF header to parse </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if the @RELATION field does not come before any other @ATTRIBUTE </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if the @RELATION field does not have a name </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if the @RELATION field does have a name with whitespaces but is not quoted </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if an @ATTRIBUTE field has the type NUMERIC <b>and</b> the name CLASS </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if an @ATTRIBUTE field does not have a name </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if an @ATTRIBUTE field does have a name with whitespaces but is not quoted </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if multiple @ATTRIBUTES with the name CLASS are provided </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if the class field does not provide any labels </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if the class field provides labels that are no enclosed in {} (ARFF nominal attributes) </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if only a single label has been provided </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if a label has been provided multiple times </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if a string label contains a whitespace </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if a header entry starts with an @ but is none of @RELATION, @ATTRIBUTE, or @DATA </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if no feature attributes are provided </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if the @DATA attribute is missing </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the necessary header information: [num_features, num_header_lines, unique_labels, label_idx] (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="ac191b22d5eb5c6c8592dc80bacf68b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac191b22d5eb5c6c8592dc80bacf68b9f">&#9670;&nbsp;</a></span>parse_arff_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real_type , typename label_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;std::size_t, std::size_t, std::vector&lt;std::vector&lt;real_type&gt; &gt;, std::vector&lt;label_type&gt; &gt; plssvm::detail::io::parse_arff_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplssvm_1_1detail_1_1io_1_1file__reader.html">file_reader</a> &amp;&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse all data points and potential label using the file <code>reader</code>, ignoring all empty lines and lines starting with an <code>%</code>. If no labels are found, returns an empty vector. </p>
<p>An example file can look like </p><div class="fragment"><div class="line">@RELATION <a class="code" href="namespaceplssvm_1_1version.html#adb9c5fe208e0936d4f46b05486516f42">name</a></div>
<div class="line"> </div>
<div class="line">@ATTRIBUTE feature_0   numeric</div>
<div class="line">@ATTRIBUTE feature_1   numeric</div>
<div class="line">@ATTRIBUTE feature_2   numeric</div>
<div class="line">@ATTRIBUTE feature_3   numeric</div>
<div class="line">@ATTRIBUTE <span class="keyword">class       </span>{-1,1}</div>
<div class="line"> </div>
<div class="line">@DATA</div>
<div class="line">-1.117827500607882,-2.9087188881250993,0.66638344270039144,1.0978832703949288,1</div>
<div class="line">-0.5282118298909262,-0.335880984968183973,0.51687296029754564,0.54604461446026,1</div>
<div class="line">0.0,0.60276937379453293,-0.13086851759108944,0.0,-1</div>
<div class="line">0.57650218263054642,1.01405596624706053,0.13009428079760464,0.7261913886869387,-1</div>
<div class="line">1.88494043717792,1.00518564317278263,0.298499933047586044,1.6464627048813514,-1</div>
<div class="ttc" id="anamespaceplssvm_1_1version_html_adb9c5fe208e0936d4f46b05486516f42"><div class="ttname"><a href="namespaceplssvm_1_1version.html#adb9c5fe208e0936d4f46b05486516f42">plssvm::version::name</a></div><div class="ttdeci">constexpr std::string_view name</div><div class="ttdoc">The name of the library.</div><div class="ttdef"><b>Definition:</b> version.hpp:26</div></div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>the floating point type </td></tr>
    <tr><td class="paramname">label_type</td><td>the type of the labels (any arithmetic type or std::string) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reader</td><td>the <a class="el" href="classplssvm_1_1detail_1_1io_1_1file__reader.html" title="The plssvm::detail::file_reader class is responsible for reading a file and splitting it into its lin...">file_reader</a> used to read the ARFF data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The features must be provided with zero-based indices! </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if no features could be found (may indicate an empty file) </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if a label couldn't be converted to the provided <code>label_type</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if a feature index couldn't be converted to <code>unsigned long</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if a feature value couldn't be converted to the provided <code>real_type</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if an '@' is read inside the @DATA section </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if a closing curly brace '}' is missing in the sparse data point description </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if an closing curly brace '{' is missing in the sparse data point description </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if a index is out-of-bounce with respect to the provided ARFF header information </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if the ARFF header specifies labels but any data point misses a label </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if the number of found features and labels mismatches the numbers provided in the ARFF header </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if a label in the data section has been found, that did not appear in the header </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a std::tuple containing: [num_data_points, num_features, data_points, labels] (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="a79aa7936c5a01d6bfd7082ec9abb0c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79aa7936c5a01d6bfd7082ec9abb0c50">&#9670;&nbsp;</a></span>write_arff_data_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real_type , typename label_type , bool has_label&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void plssvm::detail::io::write_arff_data_impl </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; real_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; label_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the provided <code>data</code> and <code>labels</code> to the ARFF file <code>filename</code>. </p>
<p>An example file can look like </p><div class="fragment"><div class="line">@RELATION <a class="code" href="namespaceplssvm_1_1version.html#adb9c5fe208e0936d4f46b05486516f42">name</a></div>
<div class="line"> </div>
<div class="line">@ATTRIBUTE feature_0   numeric</div>
<div class="line">@ATTRIBUTE feature_1   numeric</div>
<div class="line">@ATTRIBUTE feature_2   numeric</div>
<div class="line">@ATTRIBUTE feature_3   numeric</div>
<div class="line">@ATTRIBUTE <span class="keyword">class       </span>{-1,1}</div>
<div class="line"> </div>
<div class="line">@DATA</div>
<div class="line">-1.117827500607882,-2.9087188881250993,0.66638344270039144,1.0978832703949288,1</div>
<div class="line">-0.5282118298909262,-0.335880984968183973,0.51687296029754564,0.54604461446026,1</div>
<div class="line">0.0,0.60276937379453293,-0.13086851759108944,0.0,-1</div>
<div class="line">0.57650218263054642,1.01405596624706053,0.13009428079760464,0.7261913886869387,-1</div>
<div class="line">1.88494043717792,1.00518564317278263,0.298499933047586044,1.6464627048813514,-1</div>
</div><!-- fragment --><p> Note that the output will always be dense, i.e., all features with a value of <code>0.0</code> are explicitly written in the resulting file. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>the floating point type </td></tr>
    <tr><td class="paramname">label_type</td><td>the type of the labels (any arithmetic type or std::string) </td></tr>
    <tr><td class="paramname">has_label</td><td>if <code>true</code> the provided labels are also written to the file, if <code>false</code> <b>no</b> labels are outputted </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>the filename to write the data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>the data points to write to the file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">label</td><td>the labels to write to the file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The resulting order of the data points in the ARFF file is unspecified! </dd>
<dd>
The features are written using zero-based indices! </dd></dl>

</div>
</div>
<a id="a6a5792cccaf8c7589afe19482b4a26b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5792cccaf8c7589afe19482b4a26b6">&#9670;&nbsp;</a></span>write_arff_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real_type , typename label_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void plssvm::detail::io::write_arff_data </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; real_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; label_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the provided <code>data</code> and <code>labels</code> to the ARFF file <code>filename</code>. </p>
<p>An example file can look like </p><div class="fragment"><div class="line">@RELATION <a class="code" href="namespaceplssvm_1_1version.html#adb9c5fe208e0936d4f46b05486516f42">name</a></div>
<div class="line"> </div>
<div class="line">@ATTRIBUTE feature_0   numeric</div>
<div class="line">@ATTRIBUTE feature_1   numeric</div>
<div class="line">@ATTRIBUTE feature_2   numeric</div>
<div class="line">@ATTRIBUTE feature_3   numeric</div>
<div class="line">@ATTRIBUTE <span class="keyword">class       </span>{-1,1}</div>
<div class="line"> </div>
<div class="line">@DATA</div>
<div class="line">-1.117827500607882,-2.9087188881250993,0.66638344270039144,1.0978832703949288,1</div>
<div class="line">-0.5282118298909262,-0.335880984968183973,0.51687296029754564,0.54604461446026,1</div>
<div class="line">0.0,0.60276937379453293,-0.13086851759108944,0.0,-1</div>
<div class="line">0.57650218263054642,1.01405596624706053,0.13009428079760464,0.7261913886869387,-1</div>
<div class="line">1.88494043717792,1.00518564317278263,0.298499933047586044,1.6464627048813514,-1</div>
</div><!-- fragment --><p> Note that the output will always be dense, i.e., all features with a value of <code>0.0</code> are explicitly written in the resulting file. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>the floating point type </td></tr>
    <tr><td class="paramname">label_type</td><td>the type of the labels (any arithmetic type or std::string) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>the filename to write the data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>the data points to write to the file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">label</td><td>the labels to write to the file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The resulting order of the data points in the ARFF file is unspecified! </dd>
<dd>
The features are written using zero-based indices! </dd></dl>

</div>
</div>
<a id="aa72f588448e28ad163567b9f95e515c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72f588448e28ad163567b9f95e515c3">&#9670;&nbsp;</a></span>write_arff_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void plssvm::detail::io::write_arff_data </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; real_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the provided <code>data</code> to the ARFF file <code>filename</code>. </p>
<p>An example file can look like </p><div class="fragment"><div class="line">@RELATION <a class="code" href="namespaceplssvm_1_1version.html#adb9c5fe208e0936d4f46b05486516f42">name</a></div>
<div class="line"> </div>
<div class="line">@ATTRIBUTE feature_0   numeric</div>
<div class="line">@ATTRIBUTE feature_1   numeric</div>
<div class="line">@ATTRIBUTE feature_2   numeric</div>
<div class="line">@ATTRIBUTE feature_3   numeric</div>
<div class="line"> </div>
<div class="line">@DATA</div>
<div class="line">-1.117827500607882,-2.9087188881250993,0.66638344270039144,1.0978832703949288</div>
<div class="line">-0.5282118298909262,-0.335880984968183973,0.51687296029754564,0.54604461446026</div>
<div class="line">0.0,0.60276937379453293,-0.13086851759108944,0.0</div>
<div class="line">0.57650218263054642,1.01405596624706053,0.13009428079760464,0.7261913886869387</div>
<div class="line">1.88494043717792,1.00518564317278263,0.298499933047586044,1.6464627048813514</div>
</div><!-- fragment --><p> Note that the output will always be dense, i.e., all features with a value of <code>0.0</code> are explicitly written in the resulting file. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>the floating point type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>the filename to write the data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>the data points to write to the file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The resulting order of the data points in the ARFF file is unspecified! </dd>
<dd>
The features are written using zero-based indices! </dd></dl>

</div>
</div>
<a id="a0e404e093dfe9bc546a6def2275eef91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e404e093dfe9bc546a6def2275eef91">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void plssvm::detail::io::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classplssvm_1_1detail_1_1io_1_1file__reader.html">file_reader</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classplssvm_1_1detail_1_1io_1_1file__reader.html">file_reader</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elementwise swap the contents of <code>lhs</code> and <code>rhs</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>the first <a class="el" href="classplssvm_1_1detail_1_1io_1_1file__reader.html" title="The plssvm::detail::file_reader class is responsible for reading a file and splitting it into its lin...">file_reader</a> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>the second <a class="el" href="classplssvm_1_1detail_1_1io_1_1file__reader.html" title="The plssvm::detail::file_reader class is responsible for reading a file and splitting it into its lin...">file_reader</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2cb179f876b1fe3cd185ca228d0aa2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2cb179f876b1fe3cd185ca228d0aa2d">&#9670;&nbsp;</a></span>parse_libsvm_model_header()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real_type , typename label_type , typename size_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="namespaceplssvm.html#adfeda8d422840acb79679d17737238fc">plssvm::parameter</a>, real_type, std::vector&lt;label_type&gt;, std::size_t&gt; plssvm::detail::io::parse_libsvm_model_header </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string_view &gt; &amp;&#160;</td>
          <td class="paramname"><em>lines</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the LIBSVM model file header. </p>
<p>An example LIBSVM model file header for the linear kernel and two labels could look like </p><div class="fragment"><div class="line">svm_type c_svc</div>
<div class="line">kernel_type <a class="code" href="namespaceplssvm.html#aa6180d48d5afcdf753fd639d138f180ca9a932b3cb396238423eb2f33ec17d6aa">linear</a></div>
<div class="line">nr_class 2</div>
<div class="line">rho 0.37330625882191915</div>
<div class="line">label 1 -1</div>
<div class="line">total_sv 5</div>
<div class="line">nr_sv 2 3</div>
<div class="line">SV</div>
<div class="ttc" id="anamespaceplssvm_html_aa6180d48d5afcdf753fd639d138f180ca9a932b3cb396238423eb2f33ec17d6aa"><div class="ttname"><a href="namespaceplssvm.html#aa6180d48d5afcdf753fd639d138f180ca9a932b3cb396238423eb2f33ec17d6aa">plssvm::kernel_function_type::linear</a></div><div class="ttdeci">@ linear</div></div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>the floating point type </td></tr>
    <tr><td class="paramname">label_type</td><td>the type of the labels (any arithmetic type, except bool, or std::string) </td></tr>
    <tr><td class="paramname">size_type</td><td>the size type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lines</td><td>the LIBSVM model file header to parse&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if an invalid 'svm_type' has been provided, i.e., 'svm_type' is not 'c_csc' </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if an invalid 'kernel_type has been provided </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if the number of support vectors ('total_sv') is zero </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if less than two labels have been provided </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if less than two number of support vectors per label have been provided </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if an invalid header entry has been read </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if the 'svm_type' is missing </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if the 'kernel_type' is missing </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if SVM parameter are explicitly provided that are not used in the give kernel (e.g., 'gamma' is provided for the 'linear' kernel) </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if the number of classes ('nr_class') is missing </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if the total number of support vectors ('total_sv') is missing </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if the value for rho is missing </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if the labels are missing </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if the number of provided labels is not the same as the value of 'nr_class' </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if the number of support vectors per class ('nr_sv') is missing </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if the number of provided number of support vectors per class is not the same as the value of 'nr_class' </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if the number of sum of all number of support vectors per class is not the same as the value of 'total_sv' </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if no support vectors have been provided in the data section </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if the number of labels is not two </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the necessary header information: [the SVM parameter, the value of rho, the labels of the data points, num_header_lines] (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="a3d6ca0f063f1e6a8c107267326ae9182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6ca0f063f1e6a8c107267326ae9182">&#9670;&nbsp;</a></span>write_libsvm_model_header()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real_type , typename label_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;label_type&gt; plssvm::detail::io::write_libsvm_model_header </td>
          <td>(</td>
          <td class="paramtype">fmt::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceplssvm.html#adfeda8d422840acb79679d17737238fc">plssvm::parameter</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const real_type&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplssvm_1_1data__set.html">data_set</a>&lt; real_type, label_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the LIBSVM model file header to <code>out</code>. </p>
<p>An example LIBSVM model file header for the linear kernel and two labels could look like </p><div class="fragment"><div class="line">svm_type c_svc</div>
<div class="line">kernel_type <a class="code" href="namespaceplssvm.html#aa6180d48d5afcdf753fd639d138f180ca9a932b3cb396238423eb2f33ec17d6aa">linear</a></div>
<div class="line">nr_class 2</div>
<div class="line">rho 0.37330625882191915</div>
<div class="line">label 1 -1</div>
<div class="line">total_sv 5</div>
<div class="line">nr_sv 2 3</div>
<div class="line">SV</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>the floating point type </td></tr>
    <tr><td class="paramname">label_type</td><td>the type of the labels (any arithmetic type, except bool, or std::string) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>the output-stream to write the header information to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>the SVM parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rho</td><td>the rho value resulting from the hyperplane learning </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>the data used to create the model </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the order of the labels; necessary to write the data points in the correct order (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="a7bd7c8c3e979f6fd4f70f6e065850389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd7c8c3e979f6fd4f70f6e065850389">&#9670;&nbsp;</a></span>write_libsvm_model_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real_type , typename label_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void plssvm::detail::io::write_libsvm_model_data </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceplssvm.html#adfeda8d422840acb79679d17737238fc">plssvm::parameter</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const real_type&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplssvm_1_1data__set.html">data_set</a>&lt; real_type, label_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the LIBSVM model to the file <code>filename</code>. </p>
<p>An example LIBSVM model file for the linear kernel and two labels could look like </p><div class="fragment"><div class="line">svm_type c_svc</div>
<div class="line">kernel_type <a class="code" href="namespaceplssvm.html#aa6180d48d5afcdf753fd639d138f180ca9a932b3cb396238423eb2f33ec17d6aa">linear</a></div>
<div class="line">nr_class 2</div>
<div class="line">rho 0.37330625882191915</div>
<div class="line">label 1 -1</div>
<div class="line">total_sv 5</div>
<div class="line">nr_sv 2 3</div>
<div class="line">SV</div>
<div class="line">-0.17609610490769723 1:-1.117828e+00 2:-2.908719e+00 3:6.663834e-01 4:1.097883e+00</div>
<div class="line">0.8838187731213127 1:-5.282118e-01 2:-3.358810e-01 3:5.168730e-01 4:5.460446e-01</div>
<div class="line">-0.47971257671001616 1:-2.098121e-01 2:6.027694e-01 3:-1.308685e-01 4:1.080525e-01</div>
<div class="line">0.0034556484621847128 1:1.884940e+00 2:1.005186e+00 3:2.984999e-01 4:1.646463e+00</div>
<div class="line">-0.23146573996578407 1:5.765022e-01 2:1.014056e+00 3:1.300943e-01 4:7.261914e-01</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>the floating point type </td></tr>
    <tr><td class="paramname">label_type</td><td>the type of the labels (any arithmetic type, except bool, or std::string) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>the file to write the LIBSVM model to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>the SVM parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rho</td><td>the rho value resulting from the hyperplane learning </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>the weights learned by the SVM </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>the data used to create the model </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac58f53f9f473ed6db8fb23cd15a4707d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac58f53f9f473ed6db8fb23cd15a4707d">&#9670;&nbsp;</a></span>parse_libsvm_num_features()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t plssvm::detail::io::parse_libsvm_num_features </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string_view &gt; &amp;&#160;</td>
          <td class="paramname"><em>lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>skipped_lines</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse the maximum number of features per data point given in <code>lines</code>, where the first <code>skipped_lines</code> are skipped. </p>
<p>The maximum number of features equals the biggest found feature index. Since LIBSVM mandates that the features are ordered strictly increasing, it is sufficient to only look at the last feature index of each data point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lines</td><td>the LIBSVM data to parse for the number of features </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">skipped_lines</td><td>the number of lines that should be skipped at the beginning </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The features must be provided with one-based indices! </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if a feature index couldn't be converted to <code>unsigned long</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of features (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="a04b739cc5f15bdc4e4e130994ff3575a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b739cc5f15bdc4e4e130994ff3575a">&#9670;&nbsp;</a></span>parse_libsvm_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real_type , typename label_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;std::size_t, std::size_t, std::vector&lt;std::vector&lt;real_type&gt; &gt;, std::vector&lt;label_type&gt; &gt; plssvm::detail::io::parse_libsvm_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplssvm_1_1detail_1_1io_1_1file__reader.html">file_reader</a> &amp;&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>skipped_lines</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse all data points and potential label using the file <code>reader</code>, ignoring all empty lines and lines starting with an <code>#</code>. If no labels are found, returns an empty vector. </p>
<p>An example file can look like </p><div class="fragment"><div class="line">1 1:-1.117827500607882 2:-2.9087188881250993 3:0.66638344270039144 4:1.0978832703949288</div>
<div class="line">1 1:-0.5282118298909262 2:-0.335880984968183973 3:0.51687296029754564 4:0.54604461446026</div>
<div class="line">-1 1:0.57650218263054642 2:1.01405596624706053 3:0.13009428079760464 4:0.7261913886869387</div>
<div class="line">-1 1:-0.20981208921241892 2:0.60276937379453293 3:-0.13086851759108944 4:0.10805254527169827</div>
<div class="line">-1 1:1.88494043717792 2:1.00518564317278263 3:0.298499933047586044 4:1.6464627048813514</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>the floating point type </td></tr>
    <tr><td class="paramname">label_type</td><td>the type of the labels (any arithmetic type or std::string) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reader</td><td>the <a class="el" href="classplssvm_1_1detail_1_1io_1_1file__reader.html" title="The plssvm::detail::file_reader class is responsible for reading a file and splitting it into its lin...">file_reader</a> used to read the LIBSVM data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">skipped_lines</td><td>the number of lines that should be skipped at the beginning </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The features must be provided with one-based indices! </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if no features could be found (may indicate an empty file) </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if a label couldn't be converted to the provided <code>label_type</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if a feature index couldn't be converted to <code>unsigned long</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if a feature value couldn't be converted to the provided <code>real_type</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if the provided LIBSVM file uses zero-based indexing (LIBSVM mandates one-based indices) </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if the feature (indices) are not given in a strictly increasing order </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if only <b>some</b> data points are annotated with labels </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a std::tuple containing: [num_data_points, num_features, data_points, labels] (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="a536e8424f22af7875dbb721905cfc708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536e8424f22af7875dbb721905cfc708">&#9670;&nbsp;</a></span>write_libsvm_data_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real_type , typename label_type , bool has_label&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void plssvm::detail::io::write_libsvm_data_impl </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; real_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; label_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the provided <code>data</code> and <code>labels</code> to the LIBSVM file <code>filename</code>. </p>
<p>An example file can look like </p><div class="fragment"><div class="line">1 1:-1.117827500607882 3:0.66638344270039144 4:1.0978832703949288</div>
<div class="line">1 1:-0.5282118298909262 2:-0.335880984968183973 3:0.51687296029754564 4:0.54604461446026</div>
<div class="line">-1 3:0.13009428079760464 4:0.7261913886869387</div>
<div class="line">-1 1:-0.20981208921241892 2:0.60276937379453293</div>
<div class="line">-1 4:1.6464627048813514</div>
</div><!-- fragment --><p> Note that the output may be sparse, i.e., all features with a value of <code>0.0</code> are omitted in the resulting file. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>the floating point type </td></tr>
    <tr><td class="paramname">label_type</td><td>the type of the labels (any arithmetic type or std::string) </td></tr>
    <tr><td class="paramname">has_label</td><td>if <code>true</code> the provided labels are also written to the file, if <code>false</code> <b>no</b> labels are outputted </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>the filename to write the data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>the data points to write to the file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">label</td><td>the labels to write to the file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The resulting order of the data points in the LIBSVM file is unspecified! </dd>
<dd>
The features are written using one-based indices! </dd></dl>

</div>
</div>
<a id="aba6d12d43593395796b3dcbd9dcdecd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba6d12d43593395796b3dcbd9dcdecd6">&#9670;&nbsp;</a></span>write_libsvm_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real_type , typename label_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void plssvm::detail::io::write_libsvm_data </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; real_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; label_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the provided <code>data</code> and <code>labels</code> to the LIBSVM file <code>filename</code>. </p>
<p>An example file can look like </p><div class="fragment"><div class="line">1 1:-1.117827500607882 3:0.66638344270039144 4:1.0978832703949288</div>
<div class="line">1 1:-0.5282118298909262 2:-0.335880984968183973 3:0.51687296029754564 4:0.54604461446026</div>
<div class="line">-1 3:0.13009428079760464 4:0.7261913886869387</div>
<div class="line">-1 1:-0.20981208921241892 2:0.60276937379453293</div>
<div class="line">-1 4:1.6464627048813514</div>
</div><!-- fragment --><p> Note that the output may be sparse, i.e., all features with a value of <code>0.0</code> are omitted in the resulting file. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>the floating point type </td></tr>
    <tr><td class="paramname">label_type</td><td>the type of the labels (any arithmetic type or std::string) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>the filename to write the data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>the data points to write to the file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">label</td><td>the labels to write to the file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The resulting order of the data points in the LIBSVM file is unspecified! </dd>
<dd>
The features are written using one-based indices! </dd></dl>

</div>
</div>
<a id="a8b7f80352122a94464be164fe2202c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b7f80352122a94464be164fe2202c93">&#9670;&nbsp;</a></span>write_libsvm_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void plssvm::detail::io::write_libsvm_data </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; real_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the provided <code>data</code> to the LIBSVM file <code>filename</code>. </p>
<p>An example file can look like </p><div class="fragment"><div class="line">1:-1.117827500607882 3:0.66638344270039144 4:1.0978832703949288</div>
<div class="line">1:-0.5282118298909262 2:-0.335880984968183973 3:0.51687296029754564 4:0.54604461446026</div>
<div class="line">3:0.13009428079760464 4:0.7261913886869387</div>
<div class="line">1:-0.20981208921241892 2:0.60276937379453293</div>
<div class="line">4:1.6464627048813514</div>
</div><!-- fragment --><p> Note that the output may be sparse, i.e., all features with a value of <code>0.0</code> are omitted in the resulting file. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>the floating point type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>the filename to write the data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>the data points to write to the file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The resulting order of the data points in the LIBSVM file is unspecified! </dd>
<dd>
The features are written using one-based indices! </dd></dl>

</div>
</div>
<a id="a64aaa2ab0695c4fd2068fd6a41c0a362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64aaa2ab0695c4fd2068fd6a41c0a362">&#9670;&nbsp;</a></span>parse_scaling_factors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real_type , typename factors_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;std::pair&lt;real_type, real_type&gt;, std::vector&lt;factors_type&gt; &gt; plssvm::detail::io::parse_scaling_factors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplssvm_1_1detail_1_1io_1_1file__reader.html">file_reader</a> &amp;&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the scaling interval and factors stored using LIBSVM's file format from the file <code>filename</code>. </p>
<p>An example file can look like </p><div class="fragment"><div class="line">x</div>
<div class="line">-1 1</div>
<div class="line">1 -1.117827500607882 1.88494043717792</div>
<div class="line">2 -2.908718888125099 1.0140559662470605</div>
<div class="line">3 -0.13086851759108944 0.6663834427003914</div>
<div class="line">4 0.10805254527169827 1.6464627048813514</div>
</div><!-- fragment --><p> Note that the scaling factors are given using an one-based indexing scheme, but are internally stored using zero-based indexing. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>the used floating point type </td></tr>
    <tr><td class="paramname">factors_type</td><td>plssvm::data_set&lt;real_type&gt;::scaling::factors (cannot be forward declared or included) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reader</td><td>the <a class="el" href="classplssvm_1_1detail_1_1io_1_1file__reader.html" title="The plssvm::detail::file_reader class is responsible for reading a file and splitting it into its lin...">file_reader</a> used to read the scaling factors </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if the header is omitted ('x' and the scaling interval) </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if the first line doesn't only contain <code>x</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if the scaling interval is provided with more or less than two values </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if the scaling factors are provided with more or less than three values </td></tr>
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html" title="Exception type thrown if the provided file has an invalid format for the selected parser (e....">plssvm::invalid_file_format_exception</a></td><td>if the scaling factors feature index is zero-based instead of one-based </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the read scaling interval and factors (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="a6d879ca1fc76f9a75a9dc472d36686f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d879ca1fc76f9a75a9dc472d36686f5">&#9670;&nbsp;</a></span>write_scaling_factors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real_type , typename factors_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void plssvm::detail::io::write_scaling_factors </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; real_type, real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>scaling_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; factors_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>scaling_factors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the <code>scaling_interval</code> and <code>scaling_factors</code> to a file for later usage in scaling another data set using LIBSVM's file format. </p>
<p>An example file can look like </p><div class="fragment"><div class="line">x</div>
<div class="line">-1 1</div>
<div class="line">1 -1.117827500607882 1.88494043717792</div>
<div class="line">2 -2.908718888125099 1.0140559662470605</div>
<div class="line">3 -0.13086851759108944 0.6663834427003914</div>
<div class="line">4 0.10805254527169827 1.6464627048813514</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>the used floating point type </td></tr>
    <tr><td class="paramname">factors_type</td><td>plssvm::data_set&lt;real_type&gt;::scaling::factors (cannot be forward declared or included) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>the filename to write the data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scaling_interval</td><td>the valid scaling interval, i.e., [first, second] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scaling_factors</td><td>the scaling factor for each feature; given <b>zero</b> based, but written to file <b>one</b> based! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 11 2023 16:07:59 for PLSSVM - Parallel Least Squares Support Vector Machine by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
