<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PLSSVM - Parallel Least Squares Support Vector Machine: plssvm Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_90x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PLSSVM - Parallel Least Squares Support Vector Machine
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
   <div id="projectbrief">A Least Squares Support Vector Machine implementation using different backends.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">plssvm Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The main namespace containing all public API functions.  
<a href="namespaceplssvm.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceplssvm_1_1cuda"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm_1_1cuda.html">cuda</a></td></tr>
<tr class="memdesc:namespaceplssvm_1_1cuda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace containing the C-SVM using the CUDA backend. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceplssvm_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm_1_1detail.html">detail</a></td></tr>
<tr class="memdesc:namespaceplssvm_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace containing implementation details. <b>Should not</b> directly be used by users. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceplssvm_1_1dpcpp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm_1_1dpcpp.html">dpcpp</a></td></tr>
<tr class="memdesc:namespaceplssvm_1_1dpcpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace containing the C-SVM using the SYCL backend with DPC++ as SYCL implementation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceplssvm_1_1hip"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm_1_1hip.html">hip</a></td></tr>
<tr class="memdesc:namespaceplssvm_1_1hip"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace containing the C-SVM using the HIP backend. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceplssvm_1_1hipsycl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm_1_1hipsycl.html">hipsycl</a></td></tr>
<tr class="memdesc:namespaceplssvm_1_1hipsycl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace containing the C-SVM using the SYCL backend with hipSYCL as SYCL implementation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceplssvm_1_1opencl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm_1_1opencl.html">opencl</a></td></tr>
<tr class="memdesc:namespaceplssvm_1_1opencl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace containing the C-SVM using the OpenCL backend. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceplssvm_1_1openmp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm_1_1openmp.html">openmp</a></td></tr>
<tr class="memdesc:namespaceplssvm_1_1openmp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace containing the C-SVM using the OpenMP backend. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceplssvm_1_1operators"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm_1_1operators.html">operators</a></td></tr>
<tr class="memdesc:namespaceplssvm_1_1operators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace containing operator overloads for <a href="https://en.cppreference.com/w/cpp/container/vector">std::vector</a> and other mathematical functions on vectors. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceplssvm_1_1sycl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm_1_1sycl.html">sycl</a></td></tr>
<tr class="memdesc:namespaceplssvm_1_1sycl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace containing the C-SVM using the SYCL backend with the preferred SYCL implementation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceplssvm_1_1version"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm_1_1version.html">version</a></td></tr>
<tr class="memdesc:namespaceplssvm_1_1version"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace containing versioning information. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplssvm_1_1csvm__to__backend__type.html">csvm_to_backend_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="namespaceplssvm.html#abdb476fa824886f6d3ec438d86579c70" title="Enum class for all possible backend types.">plssvm::backend_type</a> of the C-SVM class of type <code>T</code>. Ignores all top-level const, volatile, and reference qualifiers.  <a href="structplssvm_1_1csvm__to__backend__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplssvm_1_1csvm.html">csvm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all C-SVM backends.  <a href="classplssvm_1_1csvm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplssvm_1_1csvm__backend__exists.html">csvm_backend_exists</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the <code>value</code> member to <code>true</code> if <code>T</code> is a C-SVM using an available backend. Ignores any top-level const, volatile, and reference qualifiers.  <a href="structplssvm_1_1csvm__backend__exists.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplssvm_1_1data__set.html">data_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulate all necessary data that is needed for training or predicting using an SVM.  <a href="classplssvm_1_1data__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplssvm_1_1default__init.html">default_init</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class denotes an explicit default value initialization used to distinguish between the default value or user provided initialization in the <code><a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a></code> class.  <a href="structplssvm_1_1default__init.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplssvm_1_1default__value.html">default_value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class encapsulates a value that may be a default value or not.  <a href="classplssvm_1_1default__value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structplssvm_1_1is__default__value.html">is_default_value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether the given type <code>T</code> is of type <code><a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">plssvm::default_value</a></code> ignoring all top-level const, volatile, and reference qualifiers.  <a href="structplssvm_1_1is__default__value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplssvm_1_1exception.html">exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all custom exception types. Forwards its message to <a href="https://en.cppreference.com/w/cpp/error/runtime_error"><code>std::runtime_error</code></a> and saves the exception name and the call side source location information.  <a href="classplssvm_1_1exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplssvm_1_1invalid__parameter__exception.html">invalid_parameter_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception type thrown if the provided parameter is invalid.  <a href="classplssvm_1_1invalid__parameter__exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplssvm_1_1file__reader__exception.html">file_reader_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception type thrown if the file_reader is used inappropriately (e.g., if two files should be opened at the same time).  <a href="classplssvm_1_1file__reader__exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplssvm_1_1data__set__exception.html">data_set_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception type thrown if a <a class="el" href="classplssvm_1_1data__set.html" title="Encapsulate all necessary data that is needed for training or predicting using an SVM.">data_set</a> is used inappropriately.  <a href="classplssvm_1_1data__set__exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplssvm_1_1file__not__found__exception.html">file_not_found_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception type thrown if the provided file couldn't be found.  <a href="classplssvm_1_1file__not__found__exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplssvm_1_1invalid__file__format__exception.html">invalid_file_format_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception type thrown if the provided file has an invalid format for the selected parser (e.g. if the arff parser tries to parse a LIBSVM file).  <a href="classplssvm_1_1invalid__file__format__exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplssvm_1_1unsupported__backend__exception.html">unsupported_backend_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception type thrown if the requested backend is not supported on the target machine.  <a href="classplssvm_1_1unsupported__backend__exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplssvm_1_1unsupported__kernel__type__exception.html">unsupported_kernel_type_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception type thrown if the requested kernel type is not supported.  <a href="classplssvm_1_1unsupported__kernel__type__exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplssvm_1_1gpu__device__ptr__exception.html">gpu_device_ptr_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception type thrown if an error in the generic <a class="el" href="classplssvm_1_1detail_1_1gpu__device__ptr.html" title="Small wrapper class around a GPU device pointer together with commonly used device functions for all ...">plssvm::detail::gpu_device_ptr</a> occurred.  <a href="classplssvm_1_1gpu__device__ptr__exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplssvm_1_1source__location.html">source_location</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classplssvm_1_1source__location.html" title="The plssvm::source_location class represents certain information about the source code,...">plssvm::source_location</a> class represents certain information about the source code, such as file names, line numbers, or function names.  <a href="classplssvm_1_1source__location.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classplssvm_1_1model.html">model</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a class encapsulating the result of a call to the SVM fit function. A model is used to predict the labels of a new data set.  <a href="classplssvm_1_1model.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aab3a343173d93c72cd62edcde3934f1a"><td class="memItemLeft" align="right" valign="top"><a id="aab3a343173d93c72cd62edcde3934f1a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#aab3a343173d93c72cd62edcde3934f1a">kernel_index_type</a> = int</td></tr>
<tr class="memdesc:aab3a343173d93c72cd62edcde3934f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer type used inside kernels. <br /></td></tr>
<tr class="separator:aab3a343173d93c72cd62edcde3934f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609fd986137bfb72338a3a241f9be501"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a609fd986137bfb72338a3a241f9be501"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a609fd986137bfb72338a3a241f9be501">optional_ref</a> = std::optional&lt; std::reference_wrapper&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a609fd986137bfb72338a3a241f9be501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for an optional reference (since <code>std::optional&lt;T&amp;&gt;</code> is not allowed).  <a href="namespaceplssvm.html#a609fd986137bfb72338a3a241f9be501">More...</a><br /></td></tr>
<tr class="separator:a609fd986137bfb72338a3a241f9be501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfeda8d422840acb79679d17737238fc"><td class="memItemLeft" align="right" valign="top"><a id="adfeda8d422840acb79679d17737238fc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#adfeda8d422840acb79679d17737238fc">parameter</a> = <a class="el" href="structplssvm_1_1detail_1_1parameter.html">detail::parameter</a>&lt; double &gt;</td></tr>
<tr class="memdesc:adfeda8d422840acb79679d17737238fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The public parameter type uses <code>double</code> to store the SVM parameters. <br /></td></tr>
<tr class="separator:adfeda8d422840acb79679d17737238fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:abdb476fa824886f6d3ec438d86579c70"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#abdb476fa824886f6d3ec438d86579c70">backend_type</a> { <br />
&#160;&#160;<a class="el" href="namespaceplssvm.html#abdb476fa824886f6d3ec438d86579c70a2bd9c0ed00116be1258e0cc66617d7c8">automatic</a>
, <a class="el" href="namespaceplssvm.html#abdb476fa824886f6d3ec438d86579c70a1dcf8ca59710cf3121728598da7a3f2f">openmp</a>
, <a class="el" href="namespaceplssvm.html#abdb476fa824886f6d3ec438d86579c70a39466fe22b062a34cfe09f3cc8c24868">cuda</a>
, <a class="el" href="namespaceplssvm.html#abdb476fa824886f6d3ec438d86579c70a997f6b054d31252dfe32ef38f9dddb2a">hip</a>
, <br />
&#160;&#160;<a class="el" href="namespaceplssvm.html#abdb476fa824886f6d3ec438d86579c70a93195db1ad73788fe96193503a7d8887">opencl</a>
, <a class="el" href="namespaceplssvm.html#abdb476fa824886f6d3ec438d86579c70af12ff9623f29ed44f5ff085b556f74f6">sycl</a>
<br />
 }</td></tr>
<tr class="memdesc:abdb476fa824886f6d3ec438d86579c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum class for all possible backend types.  <a href="namespaceplssvm.html#abdb476fa824886f6d3ec438d86579c70">More...</a><br /></td></tr>
<tr class="separator:abdb476fa824886f6d3ec438d86579c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a9e7fd7e5c3e501fb0653f392f5741"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">verbosity_level</a> { <a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741a556966c7830465dc4623d62e32cec31d">quiet</a> = 0b000
, <a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741aa3cf19501138f29d2107a275e7670846">libsvm</a> = 0b001
, <a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741a4ad8aa3a3571ea912a6ec5ea5fdcc93c">timing</a> = 0b010
, <a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741ae9dc924f238fa6cc29465942875fe8f0">full</a> = 0b100
 }</td></tr>
<tr class="memdesc:a30a9e7fd7e5c3e501fb0653f392f5741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum class for all possible verbosity levels.  <a href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">More...</a><br /></td></tr>
<tr class="separator:a30a9e7fd7e5c3e501fb0653f392f5741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54f537ac62d763f5bee20bbb4b6b21b"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#ab54f537ac62d763f5bee20bbb4b6b21b">file_format_type</a> { <a class="el" href="namespaceplssvm.html#ab54f537ac62d763f5bee20bbb4b6b21baa3cf19501138f29d2107a275e7670846">libsvm</a>
, <a class="el" href="namespaceplssvm.html#ab54f537ac62d763f5bee20bbb4b6b21ba72b5ba6932980023de5a499af2ebfb48">arff</a>
 }</td></tr>
<tr class="memdesc:ab54f537ac62d763f5bee20bbb4b6b21b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum class for all supported file types.  <a href="namespaceplssvm.html#ab54f537ac62d763f5bee20bbb4b6b21b">More...</a><br /></td></tr>
<tr class="separator:ab54f537ac62d763f5bee20bbb4b6b21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6180d48d5afcdf753fd639d138f180c"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#aa6180d48d5afcdf753fd639d138f180c">kernel_function_type</a> { <a class="el" href="namespaceplssvm.html#aa6180d48d5afcdf753fd639d138f180ca9a932b3cb396238423eb2f33ec17d6aa">linear</a> = 0
, <a class="el" href="namespaceplssvm.html#aa6180d48d5afcdf753fd639d138f180ca89693d3333328e76f4fdeed379e8f9ea">polynomial</a> = 1
, <a class="el" href="namespaceplssvm.html#aa6180d48d5afcdf753fd639d138f180ca1c2fc056f2b0d4685d95adb8764a3912">rbf</a> = 2
 }</td></tr>
<tr class="memdesc:aa6180d48d5afcdf753fd639d138f180c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum class for all implemented kernel functions.  <a href="namespaceplssvm.html#aa6180d48d5afcdf753fd639d138f180c">More...</a><br /></td></tr>
<tr class="separator:aa6180d48d5afcdf753fd639d138f180c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10012a8132e88fb2c2ea2e2f1737c500"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a10012a8132e88fb2c2ea2e2f1737c500">target_platform</a> { <br />
&#160;&#160;<a class="el" href="namespaceplssvm.html#a10012a8132e88fb2c2ea2e2f1737c500a2bd9c0ed00116be1258e0cc66617d7c8">automatic</a>
, <a class="el" href="namespaceplssvm.html#a10012a8132e88fb2c2ea2e2f1737c500ad9747e2da342bdb995f6389533ad1a3d">cpu</a>
, <a class="el" href="namespaceplssvm.html#a10012a8132e88fb2c2ea2e2f1737c500a9ec77054f198cbc11e8a492869379be0">gpu_nvidia</a>
, <a class="el" href="namespaceplssvm.html#a10012a8132e88fb2c2ea2e2f1737c500ad728f22a6cc35ec6cc635a7ffa220a45">gpu_amd</a>
, <br />
&#160;&#160;<a class="el" href="namespaceplssvm.html#a10012a8132e88fb2c2ea2e2f1737c500a14f5d066e6910bdb29ce61fcd1452598">gpu_intel</a>
<br />
 }</td></tr>
<tr class="memdesc:a10012a8132e88fb2c2ea2e2f1737c500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum class for all possible targets.  <a href="namespaceplssvm.html#a10012a8132e88fb2c2ea2e2f1737c500">More...</a><br /></td></tr>
<tr class="separator:a10012a8132e88fb2c2ea2e2f1737c500"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3ea9dba23f276dc543651130becb241a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceplssvm.html#abdb476fa824886f6d3ec438d86579c70">backend_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a3ea9dba23f276dc543651130becb241a">list_available_backends</a> ()</td></tr>
<tr class="memdesc:a3ea9dba23f276dc543651130becb241a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of all currently available backends.  <a href="namespaceplssvm.html#a3ea9dba23f276dc543651130becb241a">More...</a><br /></td></tr>
<tr class="separator:a3ea9dba23f276dc543651130becb241a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d0ebd76b678cd5ea2ed4bf5d9e1a37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceplssvm.html#abdb476fa824886f6d3ec438d86579c70">backend_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#ac4d0ebd76b678cd5ea2ed4bf5d9e1a37">determine_default_backend</a> (const std::vector&lt; <a class="el" href="namespaceplssvm.html#abdb476fa824886f6d3ec438d86579c70">backend_type</a> &gt; &amp;available_backends=<a class="el" href="namespaceplssvm.html#a3ea9dba23f276dc543651130becb241a">list_available_backends</a>(), const std::vector&lt; <a class="el" href="namespaceplssvm.html#a10012a8132e88fb2c2ea2e2f1737c500">target_platform</a> &gt; &amp;available_target_platforms=<a class="el" href="namespaceplssvm.html#a9cdf0c0e343972354666d74ba5461028">list_available_target_platforms</a>())</td></tr>
<tr class="memdesc:ac4d0ebd76b678cd5ea2ed4bf5d9e1a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the default backend (if <a class="el" href="namespaceplssvm.html#abdb476fa824886f6d3ec438d86579c70a2bd9c0ed00116be1258e0cc66617d7c8">plssvm::backend_type::automatic</a> is used) given the backend and target platform lists.  <a href="namespaceplssvm.html#ac4d0ebd76b678cd5ea2ed4bf5d9e1a37">More...</a><br /></td></tr>
<tr class="separator:ac4d0ebd76b678cd5ea2ed4bf5d9e1a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f8cc05a5611ef6448948acc48a1ea1"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a86f8cc05a5611ef6448948acc48a1ea1">operator&lt;&lt;</a> (std::ostream &amp;out, <a class="el" href="namespaceplssvm.html#abdb476fa824886f6d3ec438d86579c70">backend_type</a> backend)</td></tr>
<tr class="memdesc:a86f8cc05a5611ef6448948acc48a1ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the <code>backend</code> to the given output-stream <code>out</code>.  <a href="namespaceplssvm.html#a86f8cc05a5611ef6448948acc48a1ea1">More...</a><br /></td></tr>
<tr class="separator:a86f8cc05a5611ef6448948acc48a1ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb98983f3c24b91db983a8078e8f165"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a3cb98983f3c24b91db983a8078e8f165">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="namespaceplssvm.html#abdb476fa824886f6d3ec438d86579c70">backend_type</a> &amp;backend)</td></tr>
<tr class="memdesc:a3cb98983f3c24b91db983a8078e8f165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the input-stream <code>in</code> to initialize the <code>backend</code> type.  <a href="namespaceplssvm.html#a3cb98983f3c24b91db983a8078e8f165">More...</a><br /></td></tr>
<tr class="separator:a3cb98983f3c24b91db983a8078e8f165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c32d301c324602919245684540e3d67"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a3c32d301c324602919245684540e3d67"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classplssvm_1_1csvm.html">csvm</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a3c32d301c324602919245684540e3d67">make_csvm</a> (const <a class="el" href="namespaceplssvm.html#abdb476fa824886f6d3ec438d86579c70">backend_type</a> backend, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a3c32d301c324602919245684540e3d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new C-SVM using the <code>backend</code> type and additional parameter <code>args</code>.  <a href="namespaceplssvm.html#a3c32d301c324602919245684540e3d67">More...</a><br /></td></tr>
<tr class="separator:a3c32d301c324602919245684540e3d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2a554ae785446e35b0283c9d9d1d91"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a6a2a554ae785446e35b0283c9d9d1d91"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classplssvm_1_1csvm.html">csvm</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a6a2a554ae785446e35b0283c9d9d1d91">make_csvm</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a6a2a554ae785446e35b0283c9d9d1d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new C-SVM using the automatic backend type and the additional parameter <code>args</code>.  <a href="namespaceplssvm.html#a6a2a554ae785446e35b0283c9d9d1d91">More...</a><br /></td></tr>
<tr class="separator:a6a2a554ae785446e35b0283c9d9d1d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3387e208c11f7915f23ba85660c60c27"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3387e208c11f7915f23ba85660c60c27"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a3387e208c11f7915f23ba85660c60c27">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;val)</td></tr>
<tr class="memdesc:a3387e208c11f7915f23ba85660c60c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the wrapped value of <code>val</code> to the given output-stream <code>out</code>.  <a href="namespaceplssvm.html#a3387e208c11f7915f23ba85660c60c27">More...</a><br /></td></tr>
<tr class="separator:a3387e208c11f7915f23ba85660c60c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f1950f2e3041c405f91a539feded84"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a24f1950f2e3041c405f91a539feded84"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a24f1950f2e3041c405f91a539feded84">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;val)</td></tr>
<tr class="memdesc:a24f1950f2e3041c405f91a539feded84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the input-stream <code>in</code> to initialize the <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> <code>val</code>.  <a href="namespaceplssvm.html#a24f1950f2e3041c405f91a539feded84">More...</a><br /></td></tr>
<tr class="separator:a24f1950f2e3041c405f91a539feded84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9dfc7b24c3ef719f2074c889a9411d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1e9dfc7b24c3ef719f2074c889a9411d"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a1e9dfc7b24c3ef719f2074c889a9411d">swap</a> (<a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;lhs, <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;rhs) noexcept(noexcept(lhs.swap(rhs)))</td></tr>
<tr class="memdesc:a1e9dfc7b24c3ef719f2074c889a9411d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the content of two default_values <code>lhs</code> and <code>rhs</code>.  <a href="namespaceplssvm.html#a1e9dfc7b24c3ef719f2074c889a9411d">More...</a><br /></td></tr>
<tr class="separator:a1e9dfc7b24c3ef719f2074c889a9411d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9cb63f4c2b1601120c0ec17f5f44be"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:add9cb63f4c2b1601120c0ec17f5f44be"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#add9cb63f4c2b1601120c0ec17f5f44be">operator==</a> (const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:add9cb63f4c2b1601120c0ec17f5f44be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <b>the two active</b> values <code>lhs</code> and <code>rhs</code> for equality.  <a href="namespaceplssvm.html#add9cb63f4c2b1601120c0ec17f5f44be">More...</a><br /></td></tr>
<tr class="separator:add9cb63f4c2b1601120c0ec17f5f44be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e85e289ee7c50f2a86c82c744751ea"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad4e85e289ee7c50f2a86c82c744751ea"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#ad4e85e289ee7c50f2a86c82c744751ea">operator==</a> (const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;lhs, const T &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ad4e85e289ee7c50f2a86c82c744751ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <b>the two active</b> values <code>lhs</code> and <code>rhs</code> for equality.  <a href="namespaceplssvm.html#ad4e85e289ee7c50f2a86c82c744751ea">More...</a><br /></td></tr>
<tr class="separator:ad4e85e289ee7c50f2a86c82c744751ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02fc60d760559531c28be7d1227faac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac02fc60d760559531c28be7d1227faac"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#ac02fc60d760559531c28be7d1227faac">operator==</a> (const T &amp;lhs, const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ac02fc60d760559531c28be7d1227faac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <b>the two active</b> values <code>lhs</code> and <code>rhs</code> for equality.  <a href="namespaceplssvm.html#ac02fc60d760559531c28be7d1227faac">More...</a><br /></td></tr>
<tr class="separator:ac02fc60d760559531c28be7d1227faac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab169c2722b5b9c803ce1cc52a9c8ce41"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab169c2722b5b9c803ce1cc52a9c8ce41"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#ab169c2722b5b9c803ce1cc52a9c8ce41">operator!=</a> (const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ab169c2722b5b9c803ce1cc52a9c8ce41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <b>the two active</b> values <code>lhs</code> and <code>rhs</code> for inequality.  <a href="namespaceplssvm.html#ab169c2722b5b9c803ce1cc52a9c8ce41">More...</a><br /></td></tr>
<tr class="separator:ab169c2722b5b9c803ce1cc52a9c8ce41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a81bea1394e2bc932dc3bbbd44a4bf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a85a81bea1394e2bc932dc3bbbd44a4bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a85a81bea1394e2bc932dc3bbbd44a4bf">operator!=</a> (const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;lhs, const T &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a85a81bea1394e2bc932dc3bbbd44a4bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <b>the two active</b> values <code>lhs</code> and <code>rhs</code> for inequality.  <a href="namespaceplssvm.html#a85a81bea1394e2bc932dc3bbbd44a4bf">More...</a><br /></td></tr>
<tr class="separator:a85a81bea1394e2bc932dc3bbbd44a4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6113b6f79077d85c3902c52df9800962"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6113b6f79077d85c3902c52df9800962"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a6113b6f79077d85c3902c52df9800962">operator!=</a> (const T &amp;lhs, const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a6113b6f79077d85c3902c52df9800962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <b>the two active</b> values <code>lhs</code> and <code>rhs</code> for inequality.  <a href="namespaceplssvm.html#a6113b6f79077d85c3902c52df9800962">More...</a><br /></td></tr>
<tr class="separator:a6113b6f79077d85c3902c52df9800962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652d5b854edb19ff15f44f9f0181bbec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a652d5b854edb19ff15f44f9f0181bbec"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a652d5b854edb19ff15f44f9f0181bbec">operator&lt;</a> (const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a652d5b854edb19ff15f44f9f0181bbec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <b>the two active</b> values: <code>lhs</code> &lt; <code>rhs</code>.  <a href="namespaceplssvm.html#a652d5b854edb19ff15f44f9f0181bbec">More...</a><br /></td></tr>
<tr class="separator:a652d5b854edb19ff15f44f9f0181bbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c8f07c6819d5583e1caaaf0cb9e028"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a66c8f07c6819d5583e1caaaf0cb9e028"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a66c8f07c6819d5583e1caaaf0cb9e028">operator&lt;</a> (const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;lhs, const T &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a66c8f07c6819d5583e1caaaf0cb9e028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <b>the two active</b> values: <code>lhs</code> &lt; <code>rhs</code>.  <a href="namespaceplssvm.html#a66c8f07c6819d5583e1caaaf0cb9e028">More...</a><br /></td></tr>
<tr class="separator:a66c8f07c6819d5583e1caaaf0cb9e028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a603c93f3af8eba461c6a75291bf6e6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7a603c93f3af8eba461c6a75291bf6e6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a7a603c93f3af8eba461c6a75291bf6e6">operator&lt;</a> (const T &amp;lhs, const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a7a603c93f3af8eba461c6a75291bf6e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <b>the two active</b> values: <code>lhs</code> &lt; <code>rhs</code>.  <a href="namespaceplssvm.html#a7a603c93f3af8eba461c6a75291bf6e6">More...</a><br /></td></tr>
<tr class="separator:a7a603c93f3af8eba461c6a75291bf6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e19541130dc93e927345bddaee61d3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a66e19541130dc93e927345bddaee61d3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a66e19541130dc93e927345bddaee61d3">operator&gt;</a> (const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a66e19541130dc93e927345bddaee61d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <b>the two active</b> values: <code>lhs</code> &gt; <code>rhs</code>.  <a href="namespaceplssvm.html#a66e19541130dc93e927345bddaee61d3">More...</a><br /></td></tr>
<tr class="separator:a66e19541130dc93e927345bddaee61d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae655ff845fc3fac7c94e26ec7df29317"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae655ff845fc3fac7c94e26ec7df29317"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#ae655ff845fc3fac7c94e26ec7df29317">operator&gt;</a> (const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;lhs, const T &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ae655ff845fc3fac7c94e26ec7df29317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <b>the two active</b> values: <code>lhs</code> &gt; <code>rhs</code>.  <a href="namespaceplssvm.html#ae655ff845fc3fac7c94e26ec7df29317">More...</a><br /></td></tr>
<tr class="separator:ae655ff845fc3fac7c94e26ec7df29317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa352dd6afe4a1f30e7ddbad26c941ff0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa352dd6afe4a1f30e7ddbad26c941ff0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#aa352dd6afe4a1f30e7ddbad26c941ff0">operator&gt;</a> (const T &amp;lhs, const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:aa352dd6afe4a1f30e7ddbad26c941ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <b>the two active</b> values: <code>lhs</code> &gt; <code>rhs</code>.  <a href="namespaceplssvm.html#aa352dd6afe4a1f30e7ddbad26c941ff0">More...</a><br /></td></tr>
<tr class="separator:aa352dd6afe4a1f30e7ddbad26c941ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1ffec67976aa0fd9715986e93b3cbe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5a1ffec67976aa0fd9715986e93b3cbe"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a5a1ffec67976aa0fd9715986e93b3cbe">operator&lt;=</a> (const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a5a1ffec67976aa0fd9715986e93b3cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <b>the two active</b> values: <code>lhs</code> &lt;= <code>rhs</code>.  <a href="namespaceplssvm.html#a5a1ffec67976aa0fd9715986e93b3cbe">More...</a><br /></td></tr>
<tr class="separator:a5a1ffec67976aa0fd9715986e93b3cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb28c3334a54c383a331ac0e15fc410d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeb28c3334a54c383a331ac0e15fc410d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#aeb28c3334a54c383a331ac0e15fc410d">operator&lt;=</a> (const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;lhs, const T &amp;rhs) noexcept</td></tr>
<tr class="memdesc:aeb28c3334a54c383a331ac0e15fc410d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <b>the two active</b> values: <code>lhs</code> &lt;= <code>rhs</code>.  <a href="namespaceplssvm.html#aeb28c3334a54c383a331ac0e15fc410d">More...</a><br /></td></tr>
<tr class="separator:aeb28c3334a54c383a331ac0e15fc410d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648d7c4c224eab33013d150d1ee2f672"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a648d7c4c224eab33013d150d1ee2f672"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a648d7c4c224eab33013d150d1ee2f672">operator&lt;=</a> (const T &amp;lhs, const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a648d7c4c224eab33013d150d1ee2f672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <b>the two active</b> values: <code>lhs</code> &lt;= <code>rhs</code>.  <a href="namespaceplssvm.html#a648d7c4c224eab33013d150d1ee2f672">More...</a><br /></td></tr>
<tr class="separator:a648d7c4c224eab33013d150d1ee2f672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f6383326cbaa12cfb6f21d54c805ec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab7f6383326cbaa12cfb6f21d54c805ec"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#ab7f6383326cbaa12cfb6f21d54c805ec">operator&gt;=</a> (const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ab7f6383326cbaa12cfb6f21d54c805ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <b>the two active</b> values: <code>lhs</code> &gt;= <code>rhs</code>.  <a href="namespaceplssvm.html#ab7f6383326cbaa12cfb6f21d54c805ec">More...</a><br /></td></tr>
<tr class="separator:ab7f6383326cbaa12cfb6f21d54c805ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe0cd42dd9d745333c8d1afe34163e0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0fe0cd42dd9d745333c8d1afe34163e0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a0fe0cd42dd9d745333c8d1afe34163e0">operator&gt;=</a> (const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;lhs, const T &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a0fe0cd42dd9d745333c8d1afe34163e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <b>the two active</b> values: <code>lhs</code> &gt;= <code>rhs</code>.  <a href="namespaceplssvm.html#a0fe0cd42dd9d745333c8d1afe34163e0">More...</a><br /></td></tr>
<tr class="separator:a0fe0cd42dd9d745333c8d1afe34163e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f7dc74841060e0d4b331eb4fff87e4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af5f7dc74841060e0d4b331eb4fff87e4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#af5f7dc74841060e0d4b331eb4fff87e4">operator&gt;=</a> (const T &amp;lhs, const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:af5f7dc74841060e0d4b331eb4fff87e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <b>the two active</b> values: <code>lhs</code> &gt;= <code>rhs</code>.  <a href="namespaceplssvm.html#af5f7dc74841060e0d4b331eb4fff87e4">More...</a><br /></td></tr>
<tr class="separator:af5f7dc74841060e0d4b331eb4fff87e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41dcbf0d191ee3bb47d4875007553e81"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a41dcbf0d191ee3bb47d4875007553e81">operator&lt;&lt;</a> (std::ostream &amp;out, <a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">verbosity_level</a> verb)</td></tr>
<tr class="memdesc:a41dcbf0d191ee3bb47d4875007553e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the <code>verb</code> to the given output-stream <code>out</code>.  <a href="namespaceplssvm.html#a41dcbf0d191ee3bb47d4875007553e81">More...</a><br /></td></tr>
<tr class="separator:a41dcbf0d191ee3bb47d4875007553e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0bc86c9a21eb252801998262f42e845"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#ac0bc86c9a21eb252801998262f42e845">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">verbosity_level</a> &amp;verb)</td></tr>
<tr class="memdesc:ac0bc86c9a21eb252801998262f42e845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the input-stream <code>in</code> to initialize the <code>verb</code> level.  <a href="namespaceplssvm.html#ac0bc86c9a21eb252801998262f42e845">More...</a><br /></td></tr>
<tr class="separator:ac0bc86c9a21eb252801998262f42e845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486f90322578f527383198b72a7ee618"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">verbosity_level</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a486f90322578f527383198b72a7ee618">operator|</a> (<a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">verbosity_level</a> lhs, <a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">verbosity_level</a> rhs)</td></tr>
<tr class="memdesc:a486f90322578f527383198b72a7ee618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise-or to set multiple verbosity levels at once for a logging message.  <a href="namespaceplssvm.html#a486f90322578f527383198b72a7ee618">More...</a><br /></td></tr>
<tr class="separator:a486f90322578f527383198b72a7ee618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f24e2ded29a55d3c7189c4a04d21555"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">verbosity_level</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a3f24e2ded29a55d3c7189c4a04d21555">operator|=</a> (<a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">verbosity_level</a> &amp;lhs, <a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">verbosity_level</a> rhs)</td></tr>
<tr class="memdesc:a3f24e2ded29a55d3c7189c4a04d21555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise-or to set multiple verbosity levels at once for a logging message.  <a href="namespaceplssvm.html#a3f24e2ded29a55d3c7189c4a04d21555">More...</a><br /></td></tr>
<tr class="separator:a3f24e2ded29a55d3c7189c4a04d21555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9fc1e78195ec5ef0d535622ddd1363"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">verbosity_level</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#ade9fc1e78195ec5ef0d535622ddd1363">operator&amp;</a> (<a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">verbosity_level</a> lhs, <a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">verbosity_level</a> rhs)</td></tr>
<tr class="memdesc:ade9fc1e78195ec5ef0d535622ddd1363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise-and to check verbosity levels for a logging message.  <a href="namespaceplssvm.html#ade9fc1e78195ec5ef0d535622ddd1363">More...</a><br /></td></tr>
<tr class="separator:ade9fc1e78195ec5ef0d535622ddd1363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f671f1d9c3ef34c6cfba108d526b29f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">verbosity_level</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a3f671f1d9c3ef34c6cfba108d526b29f">operator&amp;=</a> (<a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">verbosity_level</a> &amp;lhs, <a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">verbosity_level</a> rhs)</td></tr>
<tr class="memdesc:a3f671f1d9c3ef34c6cfba108d526b29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise-and to check verbosity levels for a logging message.  <a href="namespaceplssvm.html#a3f671f1d9c3ef34c6cfba108d526b29f">More...</a><br /></td></tr>
<tr class="separator:a3f671f1d9c3ef34c6cfba108d526b29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f275702dce6c0b84768da5b134a737b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a3f275702dce6c0b84768da5b134a737b">operator&lt;&lt;</a> (std::ostream &amp;out, <a class="el" href="namespaceplssvm.html#ab54f537ac62d763f5bee20bbb4b6b21b">file_format_type</a> format)</td></tr>
<tr class="memdesc:a3f275702dce6c0b84768da5b134a737b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the <code>format</code> to the given output-stream <code>out</code>.  <a href="namespaceplssvm.html#a3f275702dce6c0b84768da5b134a737b">More...</a><br /></td></tr>
<tr class="separator:a3f275702dce6c0b84768da5b134a737b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad562aa2381287d9479f336df21b1f87e"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#ad562aa2381287d9479f336df21b1f87e">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="namespaceplssvm.html#ab54f537ac62d763f5bee20bbb4b6b21b">file_format_type</a> &amp;format)</td></tr>
<tr class="memdesc:ad562aa2381287d9479f336df21b1f87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the input-stream <code>in</code> to initialize the <code>format</code> type.  <a href="namespaceplssvm.html#ad562aa2381287d9479f336df21b1f87e">More...</a><br /></td></tr>
<tr class="separator:ad562aa2381287d9479f336df21b1f87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e284ee0e26a079aec377bf1b8436f67"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a2e284ee0e26a079aec377bf1b8436f67">operator&lt;&lt;</a> (std::ostream &amp;out, <a class="el" href="namespaceplssvm.html#aa6180d48d5afcdf753fd639d138f180c">kernel_function_type</a> kernel)</td></tr>
<tr class="memdesc:a2e284ee0e26a079aec377bf1b8436f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the <code>kernel</code> type to the given output-stream <code>out</code>.  <a href="namespaceplssvm.html#a2e284ee0e26a079aec377bf1b8436f67">More...</a><br /></td></tr>
<tr class="separator:a2e284ee0e26a079aec377bf1b8436f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca7e92393407c0b068bad079a0276fa"><td class="memItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#afca7e92393407c0b068bad079a0276fa">kernel_function_type_to_math_string</a> (<a class="el" href="namespaceplssvm.html#aa6180d48d5afcdf753fd639d138f180c">kernel_function_type</a> kernel) noexcept</td></tr>
<tr class="memdesc:afca7e92393407c0b068bad079a0276fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the mathematical representation of the kernel_type <code>kernel</code>.  <a href="namespaceplssvm.html#afca7e92393407c0b068bad079a0276fa">More...</a><br /></td></tr>
<tr class="separator:afca7e92393407c0b068bad079a0276fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03891e57f870c2ad20f02c9b92e5f529"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a03891e57f870c2ad20f02c9b92e5f529">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="namespaceplssvm.html#aa6180d48d5afcdf753fd639d138f180c">kernel_function_type</a> &amp;kernel)</td></tr>
<tr class="memdesc:a03891e57f870c2ad20f02c9b92e5f529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the input-stream <code>in</code> to initialize the <code>kernel</code> type.  <a href="namespaceplssvm.html#a03891e57f870c2ad20f02c9b92e5f529">More...</a><br /></td></tr>
<tr class="separator:a03891e57f870c2ad20f02c9b92e5f529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76872fe47a5337ea0c783648835554d"><td class="memTemplParams" colspan="2">template&lt;kernel_function_type kernel, typename real_type , typename... Args&gt; </td></tr>
<tr class="memitem:ae76872fe47a5337ea0c783648835554d"><td class="memTemplItemLeft" align="right" valign="top">real_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#ae76872fe47a5337ea0c783648835554d">kernel_function</a> (const std::vector&lt; real_type &gt; &amp;xi, const std::vector&lt; real_type &gt; &amp;xj, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ae76872fe47a5337ea0c783648835554d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of the two vectors <code>xi</code> and <code>xj</code> using the <code>kernel</code> function determined at compile-time.  <a href="namespaceplssvm.html#ae76872fe47a5337ea0c783648835554d">More...</a><br /></td></tr>
<tr class="separator:ae76872fe47a5337ea0c783648835554d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bf27465d3f51b208dd346c52b544e2"><td class="memTemplParams" colspan="2">template&lt;typename real_type &gt; </td></tr>
<tr class="memitem:ad1bf27465d3f51b208dd346c52b544e2"><td class="memTemplItemLeft" align="right" valign="top">real_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#ad1bf27465d3f51b208dd346c52b544e2">kernel_function</a> (const std::vector&lt; real_type &gt; &amp;xi, const std::vector&lt; real_type &gt; &amp;xj, const <a class="el" href="structplssvm_1_1detail_1_1parameter.html">detail::parameter</a>&lt; real_type &gt; &amp;params)</td></tr>
<tr class="memdesc:ad1bf27465d3f51b208dd346c52b544e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value of the two vectors <code>xi</code> and <code>xj</code> using the kernel function and kernel parameter stored in <code>params</code>.  <a href="namespaceplssvm.html#ad1bf27465d3f51b208dd346c52b544e2">More...</a><br /></td></tr>
<tr class="separator:ad1bf27465d3f51b208dd346c52b544e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8207c3b2bb058b15ccf74c3775a6dac"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#ac8207c3b2bb058b15ccf74c3775a6dac">equivalent</a> (const <a class="el" href="namespaceplssvm.html#adfeda8d422840acb79679d17737238fc">parameter</a> &amp;lhs, const <a class="el" href="namespaceplssvm.html#adfeda8d422840acb79679d17737238fc">parameter</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ac8207c3b2bb058b15ccf74c3775a6dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the two parameter sets <code>lhs</code> and <code>rhs</code> are <b>equivalent</b>.  <a href="namespaceplssvm.html#ac8207c3b2bb058b15ccf74c3775a6dac">More...</a><br /></td></tr>
<tr class="separator:ac8207c3b2bb058b15ccf74c3775a6dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdf0c0e343972354666d74ba5461028"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceplssvm.html#a10012a8132e88fb2c2ea2e2f1737c500">target_platform</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a9cdf0c0e343972354666d74ba5461028">list_available_target_platforms</a> ()</td></tr>
<tr class="memdesc:a9cdf0c0e343972354666d74ba5461028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of all currently available target platforms.  <a href="namespaceplssvm.html#a9cdf0c0e343972354666d74ba5461028">More...</a><br /></td></tr>
<tr class="separator:a9cdf0c0e343972354666d74ba5461028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0938b041564b39ca11e7eee5f37dbeaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceplssvm.html#a10012a8132e88fb2c2ea2e2f1737c500">target_platform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a0938b041564b39ca11e7eee5f37dbeaa">determine_default_target_platform</a> (const std::vector&lt; <a class="el" href="namespaceplssvm.html#a10012a8132e88fb2c2ea2e2f1737c500">target_platform</a> &gt; &amp;platform_device_list=<a class="el" href="namespaceplssvm.html#a9cdf0c0e343972354666d74ba5461028">list_available_target_platforms</a>())</td></tr>
<tr class="memdesc:a0938b041564b39ca11e7eee5f37dbeaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the default target platform given the available devices in <code>platform_device_list</code>.  <a href="namespaceplssvm.html#a0938b041564b39ca11e7eee5f37dbeaa">More...</a><br /></td></tr>
<tr class="separator:a0938b041564b39ca11e7eee5f37dbeaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510a230d19d4dd416e1bf4aaa6db9328"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a510a230d19d4dd416e1bf4aaa6db9328">operator&lt;&lt;</a> (std::ostream &amp;out, <a class="el" href="namespaceplssvm.html#a10012a8132e88fb2c2ea2e2f1737c500">target_platform</a> target)</td></tr>
<tr class="memdesc:a510a230d19d4dd416e1bf4aaa6db9328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the <code>target</code> platform to the given output-stream <code>out</code>.  <a href="namespaceplssvm.html#a510a230d19d4dd416e1bf4aaa6db9328">More...</a><br /></td></tr>
<tr class="separator:a510a230d19d4dd416e1bf4aaa6db9328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d5f3b9ef202de69580ae727fe7dd63"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a76d5f3b9ef202de69580ae727fe7dd63">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="namespaceplssvm.html#a10012a8132e88fb2c2ea2e2f1737c500">target_platform</a> &amp;target)</td></tr>
<tr class="memdesc:a76d5f3b9ef202de69580ae727fe7dd63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the input-stream <code>in</code> to initialize the <code>target</code> platform.  <a href="namespaceplssvm.html#a76d5f3b9ef202de69580ae727fe7dd63">More...</a><br /></td></tr>
<tr class="separator:a76d5f3b9ef202de69580ae727fe7dd63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6e333ce47a9a61098185730bfc37c69c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6e333ce47a9a61098185730bfc37c69c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceplssvm.html#abdb476fa824886f6d3ec438d86579c70">backend_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a6e333ce47a9a61098185730bfc37c69c">csvm_to_backend_type_v</a> = <a class="el" href="structplssvm_1_1csvm__to__backend__type.html">csvm_to_backend_type</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a6e333ce47a9a61098185730bfc37c69c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="namespaceplssvm.html#abdb476fa824886f6d3ec438d86579c70" title="Enum class for all possible backend types.">plssvm::backend_type</a> of the C-SVM class of type <code>T</code>. Ignores all top-level const, volatile, and reference qualifiers.  <a href="namespaceplssvm.html#a6e333ce47a9a61098185730bfc37c69c">More...</a><br /></td></tr>
<tr class="separator:a6e333ce47a9a61098185730bfc37c69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76052beb2b262c165f1811c5064ca1b5"><td class="memItemLeft" align="right" valign="top"><a id="a76052beb2b262c165f1811c5064ca1b5"></a>
constexpr <a class="el" href="namespaceplssvm.html#aab3a343173d93c72cd62edcde3934f1a">kernel_index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a76052beb2b262c165f1811c5064ca1b5">THREAD_BLOCK_SIZE</a> = 16</td></tr>
<tr class="memdesc:a76052beb2b262c165f1811c5064ca1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global compile-time constant used for internal caching. May be changed during the CMake configuration step. <br /></td></tr>
<tr class="separator:a76052beb2b262c165f1811c5064ca1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c75fadcf6b7f3ea0d1bb831a70933d"><td class="memItemLeft" align="right" valign="top"><a id="ac7c75fadcf6b7f3ea0d1bb831a70933d"></a>
constexpr <a class="el" href="namespaceplssvm.html#aab3a343173d93c72cd62edcde3934f1a">kernel_index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#ac7c75fadcf6b7f3ea0d1bb831a70933d">INTERNAL_BLOCK_SIZE</a> = 6</td></tr>
<tr class="memdesc:ac7c75fadcf6b7f3ea0d1bb831a70933d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global compile-time constant used for internal caching. May be changed during the CMake configuration step. <br /></td></tr>
<tr class="separator:ac7c75fadcf6b7f3ea0d1bb831a70933d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646c8f67a5f4710c6cb5231c5b8894f6"><td class="memItemLeft" align="right" valign="top"><a id="a646c8f67a5f4710c6cb5231c5b8894f6"></a>
constexpr <a class="el" href="namespaceplssvm.html#aab3a343173d93c72cd62edcde3934f1a">kernel_index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a646c8f67a5f4710c6cb5231c5b8894f6">OPENMP_BLOCK_SIZE</a> = 64</td></tr>
<tr class="memdesc:a646c8f67a5f4710c6cb5231c5b8894f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global compile-time constant used for internal caching in the OpenMP kernel. May be changed during the CMake configuration step. <br /></td></tr>
<tr class="separator:a646c8f67a5f4710c6cb5231c5b8894f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91de5910dfe0db16bd4a0628240e1b35"><td class="memTemplParams" colspan="2"><a id="a91de5910dfe0db16bd4a0628240e1b35"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a91de5910dfe0db16bd4a0628240e1b35"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a91de5910dfe0db16bd4a0628240e1b35">csvm_backend_exists_v</a> = <a class="el" href="structplssvm_1_1csvm__backend__exists.html">csvm_backend_exists</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a91de5910dfe0db16bd4a0628240e1b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of the <code>value</code> member to <code>true</code> if <code>T</code> is a C-SVM using an available backend. Ignores any top-level const, volatile, and reference qualifiers. <br /></td></tr>
<tr class="separator:a91de5910dfe0db16bd4a0628240e1b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155cdf72c54afd673ae8846f4eef6f5a"><td class="memTemplParams" colspan="2"><a id="a155cdf72c54afd673ae8846f4eef6f5a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a155cdf72c54afd673ae8846f4eef6f5a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a155cdf72c54afd673ae8846f4eef6f5a">is_default_value_v</a> = <a class="el" href="structplssvm_1_1is__default__value.html">is_default_value</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a155cdf72c54afd673ae8846f4eef6f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether the given type <code>T</code> is of type <code><a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">plssvm::default_value</a></code> ignoring all top-level const, volatile, and reference qualifiers. <br /></td></tr>
<tr class="separator:a155cdf72c54afd673ae8846f4eef6f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e465ac3c982596269becb61b6b0489"><td class="memItemLeft" align="right" valign="top"><a id="a01e465ac3c982596269becb61b6b0489"></a>
<a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">verbosity_level</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceplssvm.html#a01e465ac3c982596269becb61b6b0489">verbosity</a></td></tr>
<tr class="memdesc:a01e465ac3c982596269becb61b6b0489"><td class="mdescLeft">&#160;</td><td class="mdescRight">The verbosity level used in the logging function. My be changed by the user. <br /></td></tr>
<tr class="separator:a01e465ac3c982596269becb61b6b0489"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The main namespace containing all public API functions. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a609fd986137bfb72338a3a241f9be501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609fd986137bfb72338a3a241f9be501">&#9670;&nbsp;</a></span>optional_ref</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceplssvm.html#a609fd986137bfb72338a3a241f9be501">plssvm::optional_ref</a> = typedef std::optional&lt;std::reference_wrapper&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for an optional reference (since <code>std::optional&lt;T&amp;&gt;</code> is not allowed). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type to wrap as a reference </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="abdb476fa824886f6d3ec438d86579c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdb476fa824886f6d3ec438d86579c70">&#9670;&nbsp;</a></span>backend_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceplssvm.html#abdb476fa824886f6d3ec438d86579c70">plssvm::backend_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum class for all possible backend types. </p>
<dl class="section note"><dt>Note</dt><dd>All different SYCL implementations have the same backend type "sycl". </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abdb476fa824886f6d3ec438d86579c70a2bd9c0ed00116be1258e0cc66617d7c8"></a>automatic&#160;</td><td class="fielddoc"><p>The default backend. Depends on the specified target platform. </p>
</td></tr>
<tr><td class="fieldname"><a id="abdb476fa824886f6d3ec438d86579c70a1dcf8ca59710cf3121728598da7a3f2f"></a>openmp&#160;</td><td class="fielddoc"><p><a href="https://www.openmp.org/">OpenMP</a> to target CPUs only (currently no OpenMP target offloading support). </p>
</td></tr>
<tr><td class="fieldname"><a id="abdb476fa824886f6d3ec438d86579c70a39466fe22b062a34cfe09f3cc8c24868"></a>cuda&#160;</td><td class="fielddoc"><p><a href="https://developer.nvidia.com/cuda-zone">CUDA</a> to target NVIDIA GPUs only. </p>
</td></tr>
<tr><td class="fieldname"><a id="abdb476fa824886f6d3ec438d86579c70a997f6b054d31252dfe32ef38f9dddb2a"></a>hip&#160;</td><td class="fielddoc"><p><a href="https://github.com/ROCm-Developer-Tools/HIP">HIP</a> to target AMD and NVIDIA GPUs. </p>
</td></tr>
<tr><td class="fieldname"><a id="abdb476fa824886f6d3ec438d86579c70a93195db1ad73788fe96193503a7d8887"></a>opencl&#160;</td><td class="fielddoc"><p><a href="https://www.khronos.org/opencl/">OpenCL</a> to target CPUs and GPUs from different vendors. </p>
</td></tr>
<tr><td class="fieldname"><a id="abdb476fa824886f6d3ec438d86579c70af12ff9623f29ed44f5ff085b556f74f6"></a>sycl&#160;</td><td class="fielddoc"><p><a href="https://www.khronos.org/sycl/">SYCL</a> to target CPUs and GPUs from different vendors. Currently tested SYCL implementations are <a href="https://github.com/intel/llvm">DPC++</a> and <a href="https://github.com/illuhad/hipSYCL">hipSYCL</a>. </p>
</td></tr>
</table>

</div>
</div>
<a id="a30a9e7fd7e5c3e501fb0653f392f5741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a9e7fd7e5c3e501fb0653f392f5741">&#9670;&nbsp;</a></span>verbosity_level</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">plssvm::verbosity_level</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum class for all possible verbosity levels. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a30a9e7fd7e5c3e501fb0653f392f5741a556966c7830465dc4623d62e32cec31d"></a>quiet&#160;</td><td class="fielddoc"><p>Nothing is logged to the standard output. </p>
</td></tr>
<tr><td class="fieldname"><a id="a30a9e7fd7e5c3e501fb0653f392f5741aa3cf19501138f29d2107a275e7670846"></a>libsvm&#160;</td><td class="fielddoc"><p>Log the same messages as LIBSVM (used for better LIBSVM conformity). </p>
</td></tr>
<tr><td class="fieldname"><a id="a30a9e7fd7e5c3e501fb0653f392f5741a4ad8aa3a3571ea912a6ec5ea5fdcc93c"></a>timing&#160;</td><td class="fielddoc"><p>Log all messages related to timing information. </p>
</td></tr>
<tr><td class="fieldname"><a id="a30a9e7fd7e5c3e501fb0653f392f5741ae9dc924f238fa6cc29465942875fe8f0"></a>full&#160;</td><td class="fielddoc"><p>Log all messages. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab54f537ac62d763f5bee20bbb4b6b21b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54f537ac62d763f5bee20bbb4b6b21b">&#9670;&nbsp;</a></span>file_format_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceplssvm.html#ab54f537ac62d763f5bee20bbb4b6b21b">plssvm::file_format_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum class for all supported file types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab54f537ac62d763f5bee20bbb4b6b21baa3cf19501138f29d2107a275e7670846"></a>libsvm&#160;</td><td class="fielddoc"><p>The LIBSVM file format. Used as default. For the file format specification see: <a href="https://www.csie.ntu.edu.tw/~cjlin/libsvm/faq.html">https://www.csie.ntu.edu.tw/~cjlin/libsvm/faq.html</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ab54f537ac62d763f5bee20bbb4b6b21ba72b5ba6932980023de5a499af2ebfb48"></a>arff&#160;</td><td class="fielddoc"><p>The ARFF file format. For the file format specification see: <a href="https://www.cs.waikato.ac.nz/~ml/weka/arff.html">https://www.cs.waikato.ac.nz/~ml/weka/arff.html</a> </p>
</td></tr>
</table>

</div>
</div>
<a id="aa6180d48d5afcdf753fd639d138f180c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6180d48d5afcdf753fd639d138f180c">&#9670;&nbsp;</a></span>kernel_function_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceplssvm.html#aa6180d48d5afcdf753fd639d138f180c">plssvm::kernel_function_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum class for all implemented kernel functions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa6180d48d5afcdf753fd639d138f180ca9a932b3cb396238423eb2f33ec17d6aa"></a>linear&#160;</td><td class="fielddoc"><p>Linear kernel function: \(\vec{u}^T \cdot \vec{v}\). </p>
</td></tr>
<tr><td class="fieldname"><a id="aa6180d48d5afcdf753fd639d138f180ca89693d3333328e76f4fdeed379e8f9ea"></a>polynomial&#160;</td><td class="fielddoc"><p>Polynomial kernel function: \((gamma \cdot \vec{u}^T \cdot \vec{v} + coef0)^{degree}\). </p>
</td></tr>
<tr><td class="fieldname"><a id="aa6180d48d5afcdf753fd639d138f180ca1c2fc056f2b0d4685d95adb8764a3912"></a>rbf&#160;</td><td class="fielddoc"><p>Radial basis function: \(e^{(-gamma \cdot |\vec{u} - \vec{v}|^2)}\). </p>
</td></tr>
</table>

</div>
</div>
<a id="a10012a8132e88fb2c2ea2e2f1737c500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10012a8132e88fb2c2ea2e2f1737c500">&#9670;&nbsp;</a></span>target_platform</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceplssvm.html#a10012a8132e88fb2c2ea2e2f1737c500">plssvm::target_platform</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum class for all possible targets. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a10012a8132e88fb2c2ea2e2f1737c500a2bd9c0ed00116be1258e0cc66617d7c8"></a>automatic&#160;</td><td class="fielddoc"><p>The default target with respect to the used backend type. Checks for available devices in the following order: NVIDIA GPUs -&gt; AMD GPUs -&gt; Intel GPUs -&gt; CPUs. </p>
</td></tr>
<tr><td class="fieldname"><a id="a10012a8132e88fb2c2ea2e2f1737c500ad9747e2da342bdb995f6389533ad1a3d"></a>cpu&#160;</td><td class="fielddoc"><p>Target CPUs only (Intel, AMD, IBM, ...). </p>
</td></tr>
<tr><td class="fieldname"><a id="a10012a8132e88fb2c2ea2e2f1737c500a9ec77054f198cbc11e8a492869379be0"></a>gpu_nvidia&#160;</td><td class="fielddoc"><p>Target GPUs from NVIDIA. </p>
</td></tr>
<tr><td class="fieldname"><a id="a10012a8132e88fb2c2ea2e2f1737c500ad728f22a6cc35ec6cc635a7ffa220a45"></a>gpu_amd&#160;</td><td class="fielddoc"><p>Target GPUs from AMD. </p>
</td></tr>
<tr><td class="fieldname"><a id="a10012a8132e88fb2c2ea2e2f1737c500a14f5d066e6910bdb29ce61fcd1452598"></a>gpu_intel&#160;</td><td class="fielddoc"><p>Target GPUs from Intel. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3ea9dba23f276dc543651130becb241a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ea9dba23f276dc543651130becb241a">&#9670;&nbsp;</a></span>list_available_backends()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespaceplssvm.html#abdb476fa824886f6d3ec438d86579c70">backend_type</a>&gt; plssvm::list_available_backends </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of all currently available backends. </p>
<p>Only backends that where found during the CMake configuration are available. </p><dl class="section return"><dt>Returns</dt><dd>a list of the available backends (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="ac4d0ebd76b678cd5ea2ed4bf5d9e1a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d0ebd76b678cd5ea2ed4bf5d9e1a37">&#9670;&nbsp;</a></span>determine_default_backend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceplssvm.html#abdb476fa824886f6d3ec438d86579c70">backend_type</a> plssvm::determine_default_backend </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceplssvm.html#abdb476fa824886f6d3ec438d86579c70">backend_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>available_backends</em> = <code><a class="el" href="namespaceplssvm.html#a3ea9dba23f276dc543651130becb241a">list_available_backends</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceplssvm.html#a10012a8132e88fb2c2ea2e2f1737c500">target_platform</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>available_target_platforms</em> = <code><a class="el" href="namespaceplssvm.html#a9cdf0c0e343972354666d74ba5461028">list_available_target_platforms</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the default backend (if <a class="el" href="namespaceplssvm.html#abdb476fa824886f6d3ec438d86579c70a2bd9c0ed00116be1258e0cc66617d7c8">plssvm::backend_type::automatic</a> is used) given the backend and target platform lists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">available_backends</td><td>list of backends; if no backends are provided, queries all available backends </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">available_target_platforms</td><td>list of target platforms; if no target platforms are provided, queries all available target platforms </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the default backend given the backend and target platform lists (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="a86f8cc05a5611ef6448948acc48a1ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f8cc05a5611ef6448948acc48a1ea1">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; plssvm::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceplssvm.html#abdb476fa824886f6d3ec438d86579c70">backend_type</a>&#160;</td>
          <td class="paramname"><em>backend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output the <code>backend</code> to the given output-stream <code>out</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>the output-stream to write the backend type to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">backend</td><td>the backend type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output-stream </dd></dl>

</div>
</div>
<a id="a3cb98983f3c24b91db983a8078e8f165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb98983f3c24b91db983a8078e8f165">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; plssvm::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceplssvm.html#abdb476fa824886f6d3ec438d86579c70">backend_type</a> &amp;&#160;</td>
          <td class="paramname"><em>backend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the input-stream <code>in</code> to initialize the <code>backend</code> type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">in</td><td>input-stream to extract the backend type from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">backend</td><td>the backend type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the input-stream </dd></dl>

</div>
</div>
<a id="a3c32d301c324602919245684540e3d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c32d301c324602919245684540e3d67">&#9670;&nbsp;</a></span>make_csvm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classplssvm_1_1csvm.html">csvm</a>&gt; plssvm::make_csvm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplssvm.html#abdb476fa824886f6d3ec438d86579c70">backend_type</a>&#160;</td>
          <td class="paramname"><em>backend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new C-SVM using the <code>backend</code> type and additional parameter <code>args</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>the types of the parameters to initialize the C-SVM </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">backend</td><td>the backend to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>the parameters used to initialize the respective C-SVM </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1unsupported__backend__exception.html" title="Exception type thrown if the requested backend is not supported on the target machine.">plssvm::unsupported_backend_exception</a></td><td>if the <code>backend</code> is not recognized </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the C-SVM (<code>[[nodiscard]]</code>) </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="csvm_examples_8cpp-example.html#a1">csvm_examples.cpp</a>, <a class="el" href="csvm_factory_examples_8cpp-example.html#a0">csvm_factory_examples.cpp</a>, and <a class="el" href="model_examples_8cpp-example.html#a1">model_examples.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a6a2a554ae785446e35b0283c9d9d1d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2a554ae785446e35b0283c9d9d1d91">&#9670;&nbsp;</a></span>make_csvm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classplssvm_1_1csvm.html">csvm</a>&gt; plssvm::make_csvm </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new C-SVM using the automatic backend type and the additional parameter <code>args</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>the types of the parameters to initialize the C-SVM </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>the parameters used to initialize the respective C-SVM </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1unsupported__backend__exception.html" title="Exception type thrown if the requested backend is not supported on the target machine.">plssvm::unsupported_backend_exception</a></td><td>if the <code>backend</code> is not recognized </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the C-SVM (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="a3387e208c11f7915f23ba85660c60c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3387e208c11f7915f23ba85660c60c27">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; plssvm::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output the wrapped value of <code>val</code> to the given output-stream <code>out</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the wrapped value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>the output-stream to write the wrapped <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> value to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>the <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output-stream </dd></dl>

</div>
</div>
<a id="a24f1950f2e3041c405f91a539feded84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f1950f2e3041c405f91a539feded84">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; plssvm::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use the input-stream <code>in</code> to initialize the <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> <code>val</code>. </p>
<p>Sets the user defined value, i.e., <code><a class="el" href="classplssvm_1_1default__value.html#acd9a97ae5558f7a4362e51af2874a223" title="Check whether the currently active value is the default value.">plssvm::default_value::is_default()</a></code> will return <code>false</code> and the default value will <b>not</b> be used. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the wrapped value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">in</td><td>input-stream to extract the wrapped <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> value from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>the <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the input-stream </dd></dl>

</div>
</div>
<a id="a1e9dfc7b24c3ef719f2074c889a9411d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9dfc7b24c3ef719f2074c889a9411d">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void plssvm::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the content of two default_values <code>lhs</code> and <code>rhs</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lhs</td><td>the first <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>the second <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add9cb63f4c2b1601120c0ec17f5f44be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add9cb63f4c2b1601120c0ec17f5f44be">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool plssvm::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares <b>the two active</b> values <code>lhs</code> and <code>rhs</code> for equality. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the wrapped value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>the first <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the second <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the active values are equal, <code>false</code> otherwise (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="ad4e85e289ee7c50f2a86c82c744751ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e85e289ee7c50f2a86c82c744751ea">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool plssvm::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares <b>the two active</b> values <code>lhs</code> and <code>rhs</code> for equality. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the wrapped value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>the first <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the second <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the active values are equal, <code>false</code> otherwise (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="ac02fc60d760559531c28be7d1227faac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02fc60d760559531c28be7d1227faac">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool plssvm::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares <b>the two active</b> values <code>lhs</code> and <code>rhs</code> for equality. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the wrapped value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>the first <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the second <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the active values are equal, <code>false</code> otherwise (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="ab169c2722b5b9c803ce1cc52a9c8ce41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab169c2722b5b9c803ce1cc52a9c8ce41">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool plssvm::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares <b>the two active</b> values <code>lhs</code> and <code>rhs</code> for inequality. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the wrapped value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>the first <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the second <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the active values are unequal, <code>false</code> otherwise (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="a85a81bea1394e2bc932dc3bbbd44a4bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a81bea1394e2bc932dc3bbbd44a4bf">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool plssvm::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares <b>the two active</b> values <code>lhs</code> and <code>rhs</code> for inequality. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the wrapped value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>the first <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the second <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the active values are unequal, <code>false</code> otherwise (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="a6113b6f79077d85c3902c52df9800962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6113b6f79077d85c3902c52df9800962">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool plssvm::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares <b>the two active</b> values <code>lhs</code> and <code>rhs</code> for inequality. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the wrapped value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>the first <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the second <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the active values are unequal, <code>false</code> otherwise (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="a652d5b854edb19ff15f44f9f0181bbec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a652d5b854edb19ff15f44f9f0181bbec">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool plssvm::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares <b>the two active</b> values: <code>lhs</code> &lt; <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the wrapped value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>the first <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the second <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the active values of <code>lhs</code> is less than the active value of <code>rhs</code>, <code>false</code> otherwise (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="a66c8f07c6819d5583e1caaaf0cb9e028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66c8f07c6819d5583e1caaaf0cb9e028">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool plssvm::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares <b>the two active</b> values: <code>lhs</code> &lt; <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the wrapped value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>the first <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the second <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the active values of <code>lhs</code> is less than the active value of <code>rhs</code>, <code>false</code> otherwise (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="a7a603c93f3af8eba461c6a75291bf6e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a603c93f3af8eba461c6a75291bf6e6">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool plssvm::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares <b>the two active</b> values: <code>lhs</code> &lt; <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the wrapped value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>the first <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the second <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the active values of <code>lhs</code> is less than the active value of <code>rhs</code>, <code>false</code> otherwise (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="a66e19541130dc93e927345bddaee61d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e19541130dc93e927345bddaee61d3">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool plssvm::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares <b>the two active</b> values: <code>lhs</code> &gt; <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the wrapped value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>the first <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the second <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the active values of <code>lhs</code> is greater than the active value of <code>rhs</code>, <code>false</code> otherwise (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="ae655ff845fc3fac7c94e26ec7df29317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae655ff845fc3fac7c94e26ec7df29317">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool plssvm::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares <b>the two active</b> values: <code>lhs</code> &gt; <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the wrapped value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>the first <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the second <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the active values of <code>lhs</code> is greater than the active value of <code>rhs</code>, <code>false</code> otherwise (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="aa352dd6afe4a1f30e7ddbad26c941ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa352dd6afe4a1f30e7ddbad26c941ff0">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool plssvm::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares <b>the two active</b> values: <code>lhs</code> &gt; <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the wrapped value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>the first <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the second <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the active values of <code>lhs</code> is greater than the active value of <code>rhs</code>, <code>false</code> otherwise (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="a5a1ffec67976aa0fd9715986e93b3cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a1ffec67976aa0fd9715986e93b3cbe">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool plssvm::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares <b>the two active</b> values: <code>lhs</code> &lt;= <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the wrapped value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>the first <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the second <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the active values of <code>lhs</code> is less or equal than the active value of <code>rhs</code>, <code>false</code> otherwise (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="aeb28c3334a54c383a331ac0e15fc410d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb28c3334a54c383a331ac0e15fc410d">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool plssvm::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares <b>the two active</b> values: <code>lhs</code> &lt;= <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the wrapped value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>the first <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the second <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the active values of <code>lhs</code> is less or equal than the active value of <code>rhs</code>, <code>false</code> otherwise (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="a648d7c4c224eab33013d150d1ee2f672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648d7c4c224eab33013d150d1ee2f672">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool plssvm::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares <b>the two active</b> values: <code>lhs</code> &lt;= <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the wrapped value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>the first <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the second <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the active values of <code>lhs</code> is less or equal than the active value of <code>rhs</code>, <code>false</code> otherwise (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="ab7f6383326cbaa12cfb6f21d54c805ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f6383326cbaa12cfb6f21d54c805ec">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool plssvm::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares <b>the two active</b> values: <code>lhs</code> &gt;= <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the wrapped value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>the first <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the second <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the active values of <code>lhs</code> is greater or equal than the active value of <code>rhs</code>, <code>false</code> otherwise (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="a0fe0cd42dd9d745333c8d1afe34163e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe0cd42dd9d745333c8d1afe34163e0">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool plssvm::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares <b>the two active</b> values: <code>lhs</code> &gt;= <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the wrapped value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>the first <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the second <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the active values of <code>lhs</code> is greater or equal than the active value of <code>rhs</code>, <code>false</code> otherwise (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="af5f7dc74841060e0d4b331eb4fff87e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f7dc74841060e0d4b331eb4fff87e4">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool plssvm::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classplssvm_1_1default__value.html">default_value</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares <b>the two active</b> values: <code>lhs</code> &gt;= <code>rhs</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the wrapped value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>the first <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the second <a class="el" href="classplssvm_1_1default__value.html" title="This class encapsulates a value that may be a default value or not.">default_value</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the active values of <code>lhs</code> is greater or equal than the active value of <code>rhs</code>, <code>false</code> otherwise (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="a41dcbf0d191ee3bb47d4875007553e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41dcbf0d191ee3bb47d4875007553e81">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; plssvm::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">verbosity_level</a>&#160;</td>
          <td class="paramname"><em>verb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output the <code>verb</code> to the given output-stream <code>out</code>. </p>
<p>If more than one verbosity level is provided, outputs all of them, e.g., "libsvm | timing". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>the output-stream to write the verbosity level to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verb</td><td>the verbosity level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output-stream </dd></dl>

</div>
</div>
<a id="ac0bc86c9a21eb252801998262f42e845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0bc86c9a21eb252801998262f42e845">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; plssvm::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">verbosity_level</a> &amp;&#160;</td>
          <td class="paramname"><em>verb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the input-stream <code>in</code> to initialize the <code>verb</code> level. </p>
<p>If more than one verbosity level is provided, e.g., "libsvm | timing" returns a bitwise-or of the respective enum values. If any of the values is "quiet", the result will always be <code><a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741a556966c7830465dc4623d62e32cec31d">plssvm::verbosity_level::quiet</a></code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">in</td><td>input-stream to extract the verbosity level from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verb</td><td>the verbosity level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the input-stream </dd></dl>

</div>
</div>
<a id="a486f90322578f527383198b72a7ee618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486f90322578f527383198b72a7ee618">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">verbosity_level</a> plssvm::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">verbosity_level</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">verbosity_level</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise-or to set multiple verbosity levels at once for a logging message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>the first verbosity level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the second verbosity level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the logical-or of the two verbosity levels (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="a3f24e2ded29a55d3c7189c4a04d21555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f24e2ded29a55d3c7189c4a04d21555">&#9670;&nbsp;</a></span>operator|=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">verbosity_level</a> plssvm::operator|= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">verbosity_level</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">verbosity_level</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise-or to set multiple verbosity levels at once for a logging message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>the first verbosity level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the second verbosity level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the logical-or of the two verbosity levels </dd></dl>

</div>
</div>
<a id="ade9fc1e78195ec5ef0d535622ddd1363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9fc1e78195ec5ef0d535622ddd1363">&#9670;&nbsp;</a></span>operator&amp;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">verbosity_level</a> plssvm::operator&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">verbosity_level</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">verbosity_level</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise-and to check verbosity levels for a logging message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>the first verbosity level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the second verbosity level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the logical-and of the two verbosity levels (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="a3f671f1d9c3ef34c6cfba108d526b29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f671f1d9c3ef34c6cfba108d526b29f">&#9670;&nbsp;</a></span>operator&amp;=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">verbosity_level</a> plssvm::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">verbosity_level</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceplssvm.html#a30a9e7fd7e5c3e501fb0653f392f5741">verbosity_level</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bitwise-and to check verbosity levels for a logging message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>the first verbosity level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the second verbosity level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the logical-and of the two verbosity levels </dd></dl>

</div>
</div>
<a id="a3f275702dce6c0b84768da5b134a737b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f275702dce6c0b84768da5b134a737b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; plssvm::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceplssvm.html#ab54f537ac62d763f5bee20bbb4b6b21b">file_format_type</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output the <code>format</code> to the given output-stream <code>out</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>the output-stream to write the file format type to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>the file format type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output-stream </dd></dl>

</div>
</div>
<a id="ad562aa2381287d9479f336df21b1f87e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad562aa2381287d9479f336df21b1f87e">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; plssvm::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceplssvm.html#ab54f537ac62d763f5bee20bbb4b6b21b">file_format_type</a> &amp;&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the input-stream <code>in</code> to initialize the <code>format</code> type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">in</td><td>input-stream to extract the file format type from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>the file format type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the input-stream </dd></dl>

</div>
</div>
<a id="a2e284ee0e26a079aec377bf1b8436f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e284ee0e26a079aec377bf1b8436f67">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; plssvm::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceplssvm.html#aa6180d48d5afcdf753fd639d138f180c">kernel_function_type</a>&#160;</td>
          <td class="paramname"><em>kernel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output the <code>kernel</code> type to the given output-stream <code>out</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>the output-stream to write the kernel type to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kernel</td><td>the kernel type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output-stream </dd></dl>

</div>
</div>
<a id="afca7e92393407c0b068bad079a0276fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca7e92393407c0b068bad079a0276fa">&#9670;&nbsp;</a></span>kernel_function_type_to_math_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view plssvm::kernel_function_type_to_math_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceplssvm.html#aa6180d48d5afcdf753fd639d138f180c">kernel_function_type</a>&#160;</td>
          <td class="paramname"><em>kernel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the mathematical representation of the kernel_type <code>kernel</code>. </p>
<p>Uses placeholders for the scalar values and vectors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">kernel</td><td>the kernel type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the mathematical representation of <code>kernel</code> (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="a03891e57f870c2ad20f02c9b92e5f529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03891e57f870c2ad20f02c9b92e5f529">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; plssvm::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceplssvm.html#aa6180d48d5afcdf753fd639d138f180c">kernel_function_type</a> &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the input-stream <code>in</code> to initialize the <code>kernel</code> type. </p>
<p>The extracted value is matched case-insensitive and can be the integer value of the kernel_type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">in</td><td>input-stream to extract the kernel type from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kernel</td><td>the kernel type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the input-stream </dd></dl>

</div>
</div>
<a id="ae76872fe47a5337ea0c783648835554d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae76872fe47a5337ea0c783648835554d">&#9670;&nbsp;</a></span>kernel_function() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;kernel_function_type kernel, typename real_type , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">real_type plssvm::kernel_function </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>xi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>xj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the value of the two vectors <code>xi</code> and <code>xj</code> using the <code>kernel</code> function determined at compile-time. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">kernel</td><td>the type of the kernel </td></tr>
    <tr><td class="paramname">real_type</td><td>the type of the values </td></tr>
    <tr><td class="paramname">Args</td><td>additional parameters used in the respective kernel function </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xi</td><td>the first vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xj</td><td>the second vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>additional parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value computed by the <code>kernel</code> function (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="ad1bf27465d3f51b208dd346c52b544e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1bf27465d3f51b208dd346c52b544e2">&#9670;&nbsp;</a></span>kernel_function() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">real_type plssvm::kernel_function </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>xi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>xj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structplssvm_1_1detail_1_1parameter.html">detail::parameter</a>&lt; real_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the value of the two vectors <code>xi</code> and <code>xj</code> using the kernel function and kernel parameter stored in <code>params</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real_type</td><td>the type of the values </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xi</td><td>the first vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xj</td><td>the second vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>class encapsulating the kernel type and kernel parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classplssvm_1_1unsupported__kernel__type__exception.html" title="Exception type thrown if the requested kernel type is not supported.">plssvm::unsupported_kernel_type_exception</a></td><td>if the kernel function in <code>params</code> is not supported </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the computed kernel function value (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="ac8207c3b2bb058b15ccf74c3775a6dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8207c3b2bb058b15ccf74c3775a6dac">&#9670;&nbsp;</a></span>equivalent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool plssvm::equivalent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceplssvm.html#adfeda8d422840acb79679d17737238fc">parameter</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceplssvm.html#adfeda8d422840acb79679d17737238fc">parameter</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the two parameter sets <code>lhs</code> and <code>rhs</code> are <b>equivalent</b>. </p>
<p>Compares the member variables based on the <code>kernel</code>, i.e., for example for the rbf kernel both parameter sets must <b>only</b> have the same <code>gamma</code> and <code>cost</code> values <b>but</b> may differ in the values of <code>degree</code> or <code>coef0</code>. If all members should be compared regardless of the kernel type, one can use the operator== overload. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>the first parameter set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the second parameter set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both parameter sets are equivalent, <code>false</code> otherwise (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="a9cdf0c0e343972354666d74ba5461028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cdf0c0e343972354666d74ba5461028">&#9670;&nbsp;</a></span>list_available_target_platforms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespaceplssvm.html#a10012a8132e88fb2c2ea2e2f1737c500">target_platform</a>&gt; plssvm::list_available_target_platforms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of all currently available target platforms. </p>
<p>Only target platforms that where requested during the CMake configuration are available. </p><dl class="section return"><dt>Returns</dt><dd>the available target platforms (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="a0938b041564b39ca11e7eee5f37dbeaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0938b041564b39ca11e7eee5f37dbeaa">&#9670;&nbsp;</a></span>determine_default_target_platform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceplssvm.html#a10012a8132e88fb2c2ea2e2f1737c500">target_platform</a> plssvm::determine_default_target_platform </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceplssvm.html#a10012a8132e88fb2c2ea2e2f1737c500">target_platform</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>platform_device_list</em> = <code><a class="el" href="namespaceplssvm.html#a9cdf0c0e343972354666d74ba5461028">list_available_target_platforms</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the default target platform given the available devices in <code>platform_device_list</code>. </p>
<p>Does not take the currently available backends into account! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">platform_device_list</td><td>list of target_platforms found in the current setup; if no target_platforms are provided, queries all available target_platforms </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the default target_platform (<code>[[nodiscard]]</code>) </dd></dl>

</div>
</div>
<a id="a510a230d19d4dd416e1bf4aaa6db9328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a510a230d19d4dd416e1bf4aaa6db9328">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; plssvm::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceplssvm.html#a10012a8132e88fb2c2ea2e2f1737c500">target_platform</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output the <code>target</code> platform to the given output-stream <code>out</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>the output-stream to write the target platform to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>the target platform </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output-stream </dd></dl>

</div>
</div>
<a id="a76d5f3b9ef202de69580ae727fe7dd63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d5f3b9ef202de69580ae727fe7dd63">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; plssvm::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceplssvm.html#a10012a8132e88fb2c2ea2e2f1737c500">target_platform</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the input-stream <code>in</code> to initialize the <code>target</code> platform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">in</td><td>input-stream to extract the target platform from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>the target platform </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the input-stream </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a6e333ce47a9a61098185730bfc37c69c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e333ce47a9a61098185730bfc37c69c">&#9670;&nbsp;</a></span>csvm_to_backend_type_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceplssvm.html#abdb476fa824886f6d3ec438d86579c70">backend_type</a> plssvm::csvm_to_backend_type_v = <a class="el" href="structplssvm_1_1csvm__to__backend__type.html">csvm_to_backend_type</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="namespaceplssvm.html#abdb476fa824886f6d3ec438d86579c70" title="Enum class for all possible backend types.">plssvm::backend_type</a> of the C-SVM class of type <code>T</code>. Ignores all top-level const, volatile, and reference qualifiers. </p>
<p>Provides a member variable <code>value</code> if <code>T</code> is a valid C-SVM. If <code>T</code> is a SYCL C-SVM, an additional member variable <code>impl</code> is provided showing the used SYCL implementation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the C-SVM to get the backend type from</td></tr>
  </table>
  </dd>
</dl>
<p>A shorthand for <code>plssvm::csvm_to_backend_type::value</code>. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu May 11 2023 16:07:59 for PLSSVM - Parallel Least Squares Support Vector Machine by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
