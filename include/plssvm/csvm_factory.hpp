/**
 * @file
 * @author Alexander Van Craen
 * @author Marcel Breyer
 * @copyright 2018-today The PLSSVM project - All Rights Reserved
 * @license This file is part of the PLSSVM project which is released under the MIT license.
 *          See the LICENSE.md file in the project root for full license information.
 *
 * @brief Factory function for constructing a new C-SVM using one of the available backends based on the provided command line arguments.
 */

#ifndef PLSSVM_CSVM_FACTORY_HPP_
#define PLSSVM_CSVM_FACTORY_HPP_
#pragma once

#include "plssvm/backend_types.hpp"          // plssvm::backend
#include "plssvm/csvm.hpp"                   // plssvm::csvm
#include "plssvm/detail/utility.hpp"         // plssvm::detail::remove_cvref_t
#include "plssvm/exceptions/exceptions.hpp"  // plssvm::unsupported_backend_exception
#include "plssvm/kernel_function_types.hpp"  // plssvm::kernel_function_type
#include "plssvm/parameter.hpp"              // plssvm::parameter
#include "plssvm/target_platforms.hpp"       // plssvm::target_platform

// only include requested/available backends
#if defined(PLSSVM_HAS_OPENMP_BACKEND)
    #include "plssvm/backends/OpenMP/csvm.hpp"  // plssvm::openmp::csvm
#endif
#if defined(PLSSVM_HAS_CUDA_BACKEND)
    #include "plssvm/backends/CUDA/csvm.hpp"  // plssvm::cuda::csvm
#endif
#if defined(PLSSVM_HAS_HIP_BACKEND)
    #include "plssvm/backends/HIP/csvm.hpp"  // plssvm::hip::csvm
#endif
#if defined(PLSSVM_HAS_OPENCL_BACKEND)
    #include "plssvm/backends/OpenCL/csvm.hpp"  // plssvm::opencl::csvm
#endif
#if defined(PLSSVM_HAS_SYCL_BACKEND)
    #include "plssvm/backends/SYCL/implementation_type.hpp"  // plssvm::generic::sycl_implementation_type
    #if defined(PLSSVM_SYCL_BACKEND_HAS_DPCPP)
        #include "plssvm/backends/autogenerated/DPCPP/csvm.hpp"  // plssvm::dpcpp::csvm
    #endif
    #if defined(PLSSVM_SYCL_BACKEND_HAS_HIPSYCL)
        #include "plssvm/backends/autogenerated/hipSYCL/csvm.hpp"  // plssvm::hipsycl::csvm
    #endif
#endif

#include "igor/igor.hpp"  // igor::parser, igor::has_unnamed_arguments

#include <memory>       // std::unique_ptr, std::make_unique
#include <type_traits>  // std::is_same_v
#include <type_traits>  // std::enable_if_t
#include <utility>      // std::forward

namespace plssvm {

namespace detail {

/**
 * @brief Create a new C-SVM using the @p backend type and @p target platform forwarding all additional parameters to the respective C-SVM constructors.
 * @tparam Args the type of the potential additional parameter
 * @param[in] backend the backend to use
 * @param[in] target the target platform to target
 * @param[in] args the additional parameters passed on to the respective constructors
 * @return the C-SVM (`[[nodiscard]]`)
 */
template <typename... Args>
[[nodiscard]] std::unique_ptr<csvm> make_csvm_impl(const backend_type backend, const target_platform target, Args &&...args) {
    switch (backend) {
        case backend_type::automatic:
            return make_csvm_impl(determine_default_backend(), target, std::forward<Args>(args)...);
        case backend_type::openmp:
#if defined(PLSSVM_HAS_OPENMP_BACKEND)
            return std::make_unique<openmp::csvm>(target, std::forward<Args>(args)...);
#else
            throw unsupported_backend_exception{ "No OpenMP backend available!" };
#endif

        case backend_type::cuda:
#if defined(PLSSVM_HAS_CUDA_BACKEND)
            return std::make_unique<cuda::csvm<T>>(target, std::forward<Args>(args)...);
#else
            throw unsupported_backend_exception{ "No CUDA backend available!" };
#endif

        case backend_type::hip:
#if defined(PLSSVM_HAS_HIP_BACKEND)
            return std::make_unique<hip::csvm<T>>(target, std::forward<Args>(args)...);
#else
            throw unsupported_backend_exception{ "No HIP backend available!" };
#endif

        case backend_type::opencl:
#if defined(PLSSVM_HAS_OPENCL_BACKEND)
            return std::make_unique<opencl::csvm<T>>(target, kernel, std::forward<Args>(args)...);
#else
            throw unsupported_backend_exception{ "No OpenCL backend available!" };
#endif

        case backend_type::sycl:
#if defined(PLSSVM_HAS_SYCL_BACKEND)
        {
            // check igor parameter
            igor::parser parser{ args... };

            sycl_generic::implementation_type impl_type = sycl_generic::implementation_type::automatic;
            // check whether a specific SYCL implementation type has been requested
            if constexpr (parser.has(sycl_implementation_type)) {  // TODO: look at it
                // compile time check: the value must have the correct type
                static_assert(std::is_same_v<detail::remove_cvref_t<decltype(parser(sycl_implementation_type))>, sycl_generic::implementation_type>, "sycl_implementation_type must be convertible to a plssvm::sycl::implementation_type!");
                impl_type = static_cast<sycl_generic::implementation_type>(parser(sycl_implementation_type));
            }
            switch (impl_type) {
                case sycl_generic::implementation_type::automatic:
                    return std::make_unique<PLSSVM_SYCL_BACKEND_PREFERRED_IMPLEMENTATION::csvm<T>>(target, kernel, std::forward<Args>(args)...);
                case sycl_generic::implementation_type::dpcpp:
    #if defined(PLSSVM_SYCL_BACKEND_HAS_DPCPP)
                    return std::make_unique<dpcpp::csvm<T>>(target, kernel, std::forward<Args>(args)...);
    #else
                    throw unsupported_backend_exception{ "No SYCL backend using DPC++ available!" };
    #endif
                case sycl_generic::implementation_type::hipsycl:
    #if defined(PLSSVM_SYCL_BACKEND_HAS_HIPSYCL)
                    return std::make_unique<hipsycl::csvm<T>>(target, kernel, std::forward<Args>(args)...);
    #else
                    throw unsupported_backend_exception{ "No SYCL backend using hipSYCL available!" };
    #endif
            }
        }
#else
            throw unsupported_backend_exception{ "No SYCL backend available!" };
#endif
    }
    throw unsupported_backend_exception{ "Can't recognize backend !" };
}

}  // namespace detail

/**
 * @brief Create a new C-SVM using the @p backend type, @p target platform, @p kernel type, and potential additional named parameter @p named_args.
 * @tparam Args the type of the potential named parameter
 * @param[in] backend the backend to use
 * @param[in] target the target platform to target
 * @param[in] kernel the kernel function to use
 * @param[in] named_args possible additional parameters (e.g., degree parameter for the polynomial kernel)
 * @return the C-SVM (`[[nodiscard]]`)
 */
template <typename... Args, std::enable_if_t<!igor::has_unnamed_arguments<Args...>(), bool> = true>
[[nodiscard]] std::unique_ptr<csvm> make_csvm(const backend_type backend, const target_platform target, const kernel_function_type kernel, Args &&...named_args) {
    return detail::make_csvm_impl(backend, target, kernel, std::forward<Args>(named_args)...);
}
/**
 * @brief Create a new C-SVM using the @p backend type, the automatic target platform, @p kernel type, and potential additional named parameter @p named_args.
 * @tparam Args the type of the potential named parameter
 * @param[in] backend the backend to use
 * @param[in] kernel the kernel function to use
 * @param[in] named_args possible additional parameters (e.g., degree parameter for the polynomial kernel)
 * @return the C-SVM (`[[nodiscard]]`)
 */
template <typename... Args, std::enable_if_t<!igor::has_unnamed_arguments<Args...>(), bool> = true>
[[nodiscard]] std::unique_ptr<csvm> make_csvm(const backend_type backend, const kernel_function_type kernel, Args &&...named_args) {
    return make_csvm(backend, target_platform::automatic, kernel, std::forward<Args>(named_args)...);
}

/**
 * @brief Create a new C-SVM using the @p backend type, @p target platform, and @p params. Additional parameters via @p optional_named_args.
 * @details Currently only SYCL backend specific named parameters are allowed in @p optional_named_args (throws a compiler error otherwise).
 * @tparam Args the type of the potential additional parameters
 * @param[in] backend the backend to use
 * @param[in] target the target platform to target
 * @param[in] params the SVM parameters to use
 * @param[in] optional_named_args possible additional parameters (e.g., the SYCL implementation type if and only if the @p backend is SYCL)
 * @return the C-SVM (`[[nodiscard]]`)
 */
template <typename... Args, std::enable_if_t<!igor::has_unnamed_arguments<Args...>(), bool> = true>
[[nodiscard]] inline std::unique_ptr<csvm> make_csvm(const backend_type backend, const target_platform target, parameter params, Args &&...optional_named_args) {
    return detail::make_csvm_impl(backend, target, params, std::forward<Args>(optional_named_args)...);
}
/**
 * @brief Create a new C-SVM using the @p backend type, the automatic target platform, and the default SVM parameter. Additional parameters via @p optional_named_args.
 * @details Currently only SYCL backend specific named parameters are allowed in @p optional_named_args (throws a compiler error otherwise).
 * @tparam Args the type of the potential additional parameters
 * @param[in] backend the backend to use
 * @param[in] optional_named_args possible additional parameters (e.g., the SYCL implementation type if and only if the @p backend is SYCL)
 * @return the C-SVM (`[[nodiscard]]`)
 */
template <typename... Args, std::enable_if_t<!igor::has_unnamed_arguments<Args...>(), bool> = true>
[[nodiscard]] inline std::unique_ptr<csvm> make_csvm(const backend_type backend, Args &&...optional_named_args) {
    return make_csvm(backend, target_platform::automatic, parameter{}, std::forward<Args>(optional_named_args)...);
}
/**
 * @brief Create a new C-SVM using the @p backend type, the automatic target platform, and @p params. Additional parameters via @p optional_named_args.
 * @details Currently only SYCL backend specific named parameters are allowed in @p optional_named_args (throws a compiler error otherwise).
 * @tparam Args the type of the potential additional parameters
 * @param[in] backend the backend to use
 * @param[in] params the SVM parameters to use
 * @param[in] optional_named_args possible additional parameters (e.g., the SYCL implementation type if and only if the @p backend is SYCL)
 * @return the C-SVM (`[[nodiscard]]`)
 */
template <typename... Args, std::enable_if_t<!igor::has_unnamed_arguments<Args...>(), bool> = true>
[[nodiscard]] inline std::unique_ptr<csvm> make_csvm(const backend_type backend, parameter params, Args &&...optional_named_args) {
    return make_csvm(backend, target_platform::automatic, params, std::forward<Args>(optional_named_args)...);
}
/**
 * @brief Create a new C-SVM using the @p backend type, @p target platform, and the default SVM parameters. Additional parameters via @p optional_named_args.
 * @details Currently only SYCL backend specific named parameters are allowed in @p optional_named_args (throws a compiler error otherwise).
 * @tparam Args the type of the potential additional parameters
 * @param[in] backend the backend to use
 * @param[in] target the target platform to target
 * @param[in] optional_named_args possible additional parameters (e.g., the SYCL implementation type if and only if the @p backend is SYCL)
 * @return the C-SVM (`[[nodiscard]]`)
 */
template <typename... Args, std::enable_if_t<!igor::has_unnamed_arguments<Args...>(), bool> = true>
[[nodiscard]] inline std::unique_ptr<csvm> make_csvm(const backend_type backend, const target_platform target, Args &&...optional_named_args) {
    return make_csvm(backend, target, parameter{}, std::forward<Args>(optional_named_args)...);
}

}  // namespace plssvm

#endif  // PLSSVM_CSVM_FACTORY_HPP_
